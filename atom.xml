<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>for testing</title>
  
  <subtitle>by noor</subtitle>
  <link href="http://evil-must.github.io/atom.xml" rel="self"/>
  
  <link href="http://evil-must.github.io/"/>
  <updated>2020-12-02T05:33:10.897Z</updated>
  <id>http://evil-must.github.io/</id>
  
  <author>
    <name>noor</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lab 6: 网络驱动</title>
    <link href="http://evil-must.github.io/2020/12/02/lab6/"/>
    <id>http://evil-must.github.io/2020/12/02/lab6/</id>
    <published>2020-12-02T03:40:12.000Z</published>
    <updated>2020-12-02T05:33:10.897Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;本 Lab 是你可以自己进行的最后一个项目。&lt;/p&gt;
&lt;p&gt;现在你有了一个文件系统，任何一个有自尊的操作系统都不应该没有网络堆栈。在这个 Lab 中，你要写一个网络接口卡的驱动程序。该卡将基于 Intel 82540EM 芯片，也称为 E1000。&lt;/p&gt;
&lt;p&gt;然而，网卡驱动程序不足以让你的操作系统连接到互联网上。在新的 lab 6 代码中，我们为您提供了一个网络堆栈和一个网络服务器。与以前的实验一样，使用 git 获取这个实验的代码，合并到您自己的代码中，并研究新 net/ 目录中的内容，以及 kern/ 中的新文件。&lt;/p&gt;
&lt;p&gt;除了编写驱动程序外，您还需要创建一个系统调用接口，以便访问您的驱动程序。通过完成一个 web 服务器，您还可以将所有内容绑定在一起。使用新的 web 服务器，您将能够从文件系统中提供文件。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Lab 5: 文件系统</title>
    <link href="http://evil-must.github.io/2020/12/02/lab5/"/>
    <id>http://evil-must.github.io/2020/12/02/lab5/</id>
    <published>2020-12-02T03:39:12.000Z</published>
    <updated>2020-12-02T05:32:59.130Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;在这个实验中，您将实现 spawn，一个加载并在磁盘可执行文件上运行的库调用。然后，您将充实您的内核和库操作系统，足以在控制台上运行 shell。这些特性需要一个文件系统，本实验室介绍了一个简单的 读/写 文件系统。&lt;/p&gt;
&lt;h1 id=&quot;File-system-preliminaries&quot;&gt;&lt;a href=&quot;#File-system-preliminaries&quot; class=&quot;headerlink&quot; title=&quot;File system preliminaries&quot;&gt;&lt;/a&gt;File system preliminaries&lt;/h1&gt;&lt;p&gt;您将使用的文件系统比大多数 “真实” 的文件系统（包括 xv6 unix）简单得多，但它的功能足以提供基本功能：创建、读取、写入和删除以分层目录结构组织的文件。&lt;/p&gt;
&lt;p&gt;我们目前（无论如何）只开发一个单用户操作系统，它提供足够的保护来捕捉错误，但不能保护多个相互怀疑的用户。因此，我们的文件系统不支持 UNIX 文件所有权或权限的概念。我们的文件系统目前也不支持硬链接、符号链接、时间戳或像大多数 UNIX 文件系统那样的特殊设备文件。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Lab 4: 抢占式多任务调度</title>
    <link href="http://evil-must.github.io/2020/12/02/lab4/"/>
    <id>http://evil-must.github.io/2020/12/02/lab4/</id>
    <published>2020-12-02T03:38:12.000Z</published>
    <updated>2020-12-02T05:32:51.139Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;在此 Lab 中，您将在多个同时处于活动状态的用户模式环境中实现抢占式多任务处理。&lt;/p&gt;
&lt;p&gt;在 A 部分中，您将向 JOS 添加多处理器支持，实现循环调度，并添加基本环境管理系统调用（创建和销毁环境的调用，以及分配/映射内存）。&lt;/p&gt;
&lt;p&gt;在 B 部分中，您将实现一个像 Unix 一样 fork()，它允许用户模式环境创建自己的副本。&lt;/p&gt;
&lt;p&gt;最后，在 C 部分中，您将添加对进程间通信 （IPC） 的支持，允许不同的用户模式环境显式相互通信和同步。您还将添加对硬件时钟中断和抢占的支持。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Lab 3：用户环境</title>
    <link href="http://evil-must.github.io/2020/12/02/lab3/"/>
    <id>http://evil-must.github.io/2020/12/02/lab3/</id>
    <published>2020-12-02T03:37:12.000Z</published>
    <updated>2020-12-02T05:32:40.371Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;在此 lab 中，您将实现运行受保护的用户模式环境（即”进程”）所需的基本内核功能。您将增强 JOS 内核以设置数据结构来跟踪用户环境、创建单个用户环境、将程序映像加载到其中，并启动运行。您还将使 JOS 内核能够处理用户环境进行的任何系统调用并处理它导致的任何其他异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt;在此实验中，术语 &lt;em&gt;environment&lt;/em&gt; 和 &lt;em&gt;process&lt;/em&gt; 是可互换的 - 两者都指允许您运行程序的抽象。我们引入术语 “&lt;em&gt;environment&lt;/em&gt;“ 而不是传统术语 “&lt;em&gt;process&lt;/em&gt;“，以强调 JOS 环境和 UNIX 进程提供不同接口，并且不提供相同的语义。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Lab 2：内存管理</title>
    <link href="http://evil-must.github.io/2020/12/02/lab2/"/>
    <id>http://evil-must.github.io/2020/12/02/lab2/</id>
    <published>2020-12-02T03:27:12.000Z</published>
    <updated>2020-12-02T05:32:17.470Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;为操作系统编写内存管理代码。内存管理包含两个组件。&lt;/p&gt;
&lt;p&gt;第一个组件是内核的 &lt;em&gt;物理内存分配器&lt;/em&gt;，以便内核可以分配和释放内存。分配器以 4096 字节为单位操作，称为 &lt;em&gt;pages&lt;/em&gt;。任务是维护数据结构，该数据结构记录哪些物理页是空闲的，哪些已分配的，以及有多少个进程共享每个分配的页。还将编写例程来分配和释放内存页面。&lt;/p&gt;
&lt;p&gt;内存管理的第二个组件是 &lt;em&gt;虚拟内存&lt;/em&gt;，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。当指令使用内存时，x86 硬件的内存管理单元（MMU）执行映射。根据提供的规范修改 JOS 以设置 MMU 的页表。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>序章</title>
    <link href="http://evil-must.github.io/2020/12/01/hello-world/"/>
    <id>http://evil-must.github.io/2020/12/01/hello-world/</id>
    <published>2020-12-01T04:12:12.000Z</published>
    <updated>2020-12-02T03:50:56.751Z</updated>
    
    
    <summary type="html">&lt;p&gt;做一个记录吧，对我的余生。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
