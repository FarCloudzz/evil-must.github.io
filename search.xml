<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>序章</title>
    <url>/2020/12/01/hello-world/</url>
    <content><![CDATA[<p>做一个记录吧，对我的余生。</p>
<a id="more"></a>


]]></content>
  </entry>
  <entry>
    <title>Lab 2：内存管理</title>
    <url>/2020/12/02/lab2/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>为操作系统编写内存管理代码。内存管理包含两个组件。</p>
<p>第一个组件是内核的 <em>物理内存分配器</em>，以便内核可以分配和释放内存。分配器以 4096 字节为单位操作，称为 <em>pages</em>。任务是维护数据结构，该数据结构记录哪些物理页是空闲的，哪些已分配的，以及有多少个进程共享每个分配的页。还将编写例程来分配和释放内存页面。</p>
<p>内存管理的第二个组件是 <em>虚拟内存</em>，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。当指令使用内存时，x86 硬件的内存管理单元（MMU）执行映射。根据提供的规范修改 JOS 以设置 MMU 的页表。</p>
<a id="more"></a>

<h2 id="Part-1：Physical-Page-Management"><a href="#Part-1：Physical-Page-Management" class="headerlink" title="Part 1：Physical Page Management"></a>Part 1：Physical Page Management</h2><p>操作系统必须跟踪物理 RAM 的使用情况。JOS 以页为粒度管理 PC 的物理内存，这样它就可以使用 MMU 来映射和保护分配的每一块内存。</p>
<p>编写一个物理页分配器。它通过 struct PageInfo 对象的链接列表来跟踪那些页面是空闲的，每个对象对应一个物理页面。</p>
<p>在编写剩余的虚拟内存实现之前，需要先编写物理页分配器，因为页表管理代码将需要分配用于存储页表的物理内存。</p>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1."></a>Exercise 1.</h4><p>实现 kern/pmap.c 中以下几个函数，用 <code>check_page_free_list()</code> 和 <code>check_page_alloc()</code> 检查。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boot_alloc()</span><br><span class="line">mem_init()</span><br><span class="line">page_init()</span><br><span class="line">page_alloc()</span><br><span class="line">page_free()</span><br></pre></td></tr></table></figure>

<h4 id="boot-alloc"><a href="#boot-alloc" class="headerlink" title="boot_alloc()"></a>boot_alloc()</h4><p>此简单的物理内存分配器仅在 JOS 设置其虚拟内存系统时使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LAB 2: Your code here.</span></span><br><span class="line">result = nextfree;</span><br><span class="line">nextfree = ROUNDUP(nextfree + n, PGSIZE);</span><br><span class="line">cprintf(<span class="string">&quot;boot_alloc is succeed, nextfree is %x\n&quot;</span>, 		nextfree);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<h4 id="mem-init"><a href="#mem-init" class="headerlink" title="mem_init()"></a>mem_init()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">mem_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> cr0;</span><br><span class="line">	<span class="keyword">size_t</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//探测内存大小</span></span><br><span class="line">    i386_detect_memory();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建初始页目录</span></span><br><span class="line">    kern_pgdir = (<span class="keyword">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line">	<span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分配一组 npages 数量的 PageInfo 结构，并将其储存在</span></span><br><span class="line">    <span class="comment">//pages 中。内核使用这个数组跟踪物理页：每一个物理页，在这个</span></span><br><span class="line">    <span class="comment">//数组中都有一个相关的 PageInfo 结构。&#x27;npages&#x27;代表内存中物</span></span><br><span class="line">    <span class="comment">//理页的数量。使用 memset 将每一个 PageInfo 结构中的所有域</span></span><br><span class="line">    <span class="comment">//都初始化为 0。</span></span><br><span class="line">    <span class="comment">//Your code goes here:</span></span><br><span class="line">    pages = (struct PageInfo*) boot_alloc(<span class="keyword">sizeof</span>(struct PageInfo) * npages);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//现在已经分配了初始的内核数据结构，接着设置空闲物理页的列表。</span></span><br><span class="line">    <span class="comment">//一旦实现，此后的内存管理都需要通过 page_* 函数。而且，我们</span></span><br><span class="line">    <span class="comment">//现在可以使用 boot_map_region 或 page_insert 实现内存映</span></span><br><span class="line">    <span class="comment">//射。</span></span><br><span class="line">    page_init();</span><br><span class="line"></span><br><span class="line">	check_page_free_list(<span class="number">1</span>);</span><br><span class="line">	check_page_alloc();</span><br><span class="line">	check_page();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="page-init"><a href="#page-init" class="headerlink" title="page_init()"></a>page_init()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化页结构和可用内存列表。</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">page_init(<span class="keyword">void</span>)&#123;</span><br><span class="line">	<span class="comment">//按照以下要求标记物理页</span></span><br><span class="line">	<span class="comment">// 1）将物理页 0 标记为使用中。不放入空闲列表即可。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2）余下的基本内存标记为空闲，[PGSIZE, npages_basemem *</span></span><br><span class="line">    <span class="comment">//PGSIZE)</span></span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 3）IO hole [IOPHYSMEM, EXTPHYSMEM)，不能被分配。</span></span><br><span class="line">	<span class="comment">// 4) Then extended memory [EXTPHYSMEM, ...)。除去物理</span></span><br><span class="line">	<span class="comment">//内存中,内核，页表以及其他数据结构占据的页之外，其他的标记为空</span></span><br><span class="line">	<span class="comment">//闲页。</span></span><br><span class="line">	<span class="keyword">char</span> *nextfree = boot_alloc(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">size_t</span> kern_end_page = PGNUM(PADDR(nextfree));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = kern_end_page; i &lt; npages; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="page-alloc"><a href="#page-alloc" class="headerlink" title="page_alloc()"></a>page_alloc()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分配一个物理页。If(alloc_flags &amp; ALLOC_ZERO)，用&quot;0&quot;字节填充整</span></span><br><span class="line"><span class="comment">//个返回的物理页面。</span></span><br><span class="line"><span class="comment">//设置已分配页的 pp_link 为 NULL。</span></span><br><span class="line"><span class="comment">//内存不足时返回 NULL。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>*</span></span><br><span class="line"><span class="class"><span class="title">page_alloc</span>(<span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (!page_free_list) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span>;</span></span><br><span class="line">    pp = page_free_list;</span><br><span class="line">    page_free_list = page_free_list-&gt;pp_link;</span><br><span class="line">    pp-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO) &#123;</span><br><span class="line">        <span class="keyword">void</span>* va = page2kva(pp);</span><br><span class="line">        <span class="built_in">memset</span>(va, <span class="string">&#x27;\0&#x27;</span>, PGSIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="page-free"><a href="#page-free" class="headerlink" title="page_free()"></a>page_free()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一页到空闲列表。</span></span><br><span class="line"><span class="comment">//此函数仅在 pp-&gt;pp_ref 为 0 时被调用。</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">page_free(struct PageInfo *pp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果 pp-&gt;pp_ref 非零或 pp-&gt;pp_link 非空，panic。</span></span><br><span class="line">    <span class="keyword">if</span> (pp-&gt;pp_ref || pp-&gt;pp_link) &#123;</span><br><span class="line">        panic(<span class="string">&quot;This page is using!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pp-&gt;pp_link = page_free_list;</span><br><span class="line">    page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h2><p>熟悉 x86 的保护模式内存管理架构：分段和页面转换。</p>
<h3 id="Virtual-Linear-and-Physical-Addresses"><a href="#Virtual-Linear-and-Physical-Addresses" class="headerlink" title="Virtual, Linear, and Physical Addresses"></a>Virtual, Linear, and Physical Addresses</h3><p>在 x86 术语中，虚拟地址由段选择器和段内偏移组成。线性地址是段翻译后，页面翻译之前获得的地址。物理地址是在段翻译和页面翻译之后最终得到的地址。</p>
<p><img src="C:\Users\dier\Pictures\QQ截图20200715191038.png"></p>
<h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2."></a>Exercise 2.</h4><blockquote>
<p>阅读 <a href="../../readings/i386/toc.html">Intel 80386 Reference Manual</a>。仔细阅读有关页面转换和基于页面的保护的部分（5.2和6.4）。</p>
</blockquote>
<h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3."></a>Exercise 3.</h4><blockquote>
<p>进入 QEMU 的 Monitor ，练习使用 QEMU 的 info pg/mem 等命令。</p>
</blockquote>
<p>从 CPU 上执行的代码开始，一旦我们进入保护模式，就无法直接使用线性地址或物理地址。所有内存引用都解释为虚拟地址，并由 MMU 翻译，这意味着 C 中的所有指针都是虚拟地址。</p>
<p>JOS 内核通常需要将地址作为不透明值或整数进行操作，而不取消引用它们，例如在物理内存分配器中。有时这些是虚拟地址，有时是物理地址。为了帮助记录代码，JOS 源区分了两种情况：<code>uintptr_t</code> 表示虚拟地址，<code>physaddr_t</code> 表示物理地址。</p>
<h4 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h4><ol>
<li>判断变量 x 的类型，uinptr_t 还是 physaddr_t。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mystery_t x;</span><br><span class="line">char* value &#x3D; return_a_pointer();</span><br><span class="line">*value &#x3D; 10;</span><br><span class="line">x &#x3D; (mystery_t) value;</span><br></pre></td></tr></table></figure>

<h3 id="Reference-counting"><a href="#Reference-counting" class="headerlink" title="Reference counting"></a>Reference counting</h3><p>在将来的 lab 中，您通常会同时在多个虚拟地址（或在多个环境的地址空间）上映射相同的物理页面。你将在物理页的 PageInfo 结构的 pp_ref 字段保存对该页面的引用计数。当物理页的此计数为零时，可以释放该页，因为它不再使用。通常，此计数应等于物理页面在所有页表中显示在 UTOP 下方的次数（Utop 上面的映射大多由内核在启动时设置， 不应被释放， 因此无需对它们引用计数）。我们还将使用它来跟踪我们保留到页目录页的指针数，进而跟踪页目录对页表页引用的数量。</p>
<p>使用 page_alloc 应当小心。它返回页面的引用计数始终为 0 ，所以一旦对返回的页面做了一些事情，pp_ref 应当递增（比如将之插入页表）。有时这会被其他函数（page_insert）解决，有时被 page_alloc 直接执行。</p>
<h3 id="Page-Table-Management"><a href="#Page-Table-Management" class="headerlink" title="Page Table Management"></a>Page Table Management</h3><p>现在，您将编写一组例程来管理页表：插入和删除线性地址到物理地址的映射，并根据需要创建页表页。</p>
<h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4."></a>Exercise 4.</h4><p>实现 kern/pmap.c 中以下几个函数，用 <code>check_page()</code> 检查。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pgdir_walk()</span><br><span class="line">boot_map_region()</span><br><span class="line">page_lookup()</span><br><span class="line">page_remove()</span><br><span class="line">page_insert()</span><br></pre></td></tr></table></figure>

<h4 id="pgdir-walk"><a href="#pgdir-walk" class="headerlink" title="pgdir_walk()"></a>pgdir_walk()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&#x27;pgdir&#x27;是指向页目录的指针，pgdir_walk 返回一个指针指向线性地址</span></span><br><span class="line"><span class="comment">//&#x27;va&#x27; 指代的页表条目（PTE）。这需要访问二级页表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但相关的页表页可能不存在。</span></span><br><span class="line"><span class="comment">//如果为真，并且 create == false，那么返回 NULL。</span></span><br><span class="line"><span class="comment">//否则，pgdir_walk 使用 page_alloc 分配一张新页表页。</span></span><br><span class="line"><span class="comment">// -如何分配失败，返回NULL；</span></span><br><span class="line"><span class="comment">// -否则，新页面的引用计数递增，页面清除，并且 pgdir_walk 返回一</span></span><br><span class="line"><span class="comment">//个指针指向新的页表页。</span></span><br><span class="line"><span class="comment">//提示 1：使用 kern/pmap.h 中的 page2pa() 可以将一个 </span></span><br><span class="line"><span class="comment">//PageInfo* 转换为页面的物理地址。</span></span><br><span class="line"><span class="comment">//提示 2：x86 MMU 检查页目录和页表中的权限位，因此在页目录中</span></span><br><span class="line"><span class="comment">//保留权限比严格要求的权限更宽松是安全的。</span></span><br><span class="line"><span class="keyword">pte_t</span> *</span><br><span class="line">pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> pdx = PDX(va);</span><br><span class="line">	<span class="keyword">uint32_t</span> ptx = PTX(va);</span><br><span class="line">    <span class="keyword">pde_t</span> *pde; </span><br><span class="line">	pde = &amp;pgdir[pdx];</span><br><span class="line">    <span class="keyword">pde_t</span> *pte;</span><br><span class="line">    <span class="keyword">if</span> (*pde &amp; PTE_P) &#123;</span><br><span class="line">        pte = KADDR(PTE_ADDR(*pde));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (create) &#123;</span><br><span class="line">        	struct PageInfo* pp = page_alloc(ALLOC_ZERO);</span><br><span class="line">            <span class="keyword">if</span> (!pp) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			pp-&gt;pp_ref++;</span><br><span class="line">			pte = page2kva(pp);</span><br><span class="line">			*pde = page2pa(pp) | PTE_P | PTE_U | PTE_W;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;pte[ptx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="boot-map-region"><a href="#boot-map-region" class="headerlink" title="boot_map_region()"></a>boot_map_region()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将虚拟地址空间的[va，va+size）映射到以 pgdir 为根的页表中的物理</span></span><br><span class="line"><span class="comment">// 地址[pa，pa+size]。Size 是 PGSIZE 的倍数，va 和 pa 都是页对</span></span><br><span class="line"><span class="comment">// 齐的。</span></span><br><span class="line"><span class="comment">// 条目权限位 perm | PTE_P。</span></span><br><span class="line"><span class="comment">// 此函数只用于在UTOP上设置“static”映射。因此，它不应该更改映</span></span><br><span class="line"><span class="comment">// 射页上的 pp_ref 字段。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="page-lookup"><a href="#page-lookup" class="headerlink" title="page_lookup()"></a>page_lookup()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回虚拟地址 &#x27;va&#x27; 映射的页面。</span></span><br><span class="line"><span class="comment">//If pte_store 不为 0，那么就把这个页面的 pte 地址储存在</span></span><br><span class="line"><span class="comment">//pte_store 中。</span></span><br><span class="line"><span class="comment">//返回 NULL，如果地址 va 没有映射页面。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>*</span></span><br><span class="line"><span class="class"><span class="title">page_lookup</span>(<span class="title">pde_t</span> *<span class="title">pgdir</span>, <span class="title">void</span> *<span class="title">va</span>, <span class="title">pte_t</span> **<span class="title">pte_store</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span>;</span></span><br><span class="line">    <span class="keyword">pte_t</span> *pte;</span><br><span class="line">    pte = pgdir_walk(pgdir, va, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pte) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pte_store) &#123;</span><br><span class="line">            *pte_store = pte;</span><br><span class="line">        &#125;</span><br><span class="line">        pp = pa2page(PTE_ADDR(*pte));</span><br><span class="line">        <span class="keyword">return</span> pp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="page-remove"><a href="#page-remove" class="headerlink" title="page_remove()"></a>page_remove()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取消虚拟地址 &#x27;va&#x27; 处物理页的映射。</span></span><br><span class="line"><span class="comment">//如果该地址处没有物理页，则什么也不做。</span></span><br><span class="line"><span class="comment">//Details：</span></span><br><span class="line"><span class="comment">//-物理页的 ref 应当递减;</span></span><br><span class="line"><span class="comment">//-若 ref 减为零则应当释放物理页;</span></span><br><span class="line"><span class="comment">//-若 &#x27;va&#x27; 对应的 PTE 存在则应当设为 0;</span></span><br><span class="line"><span class="comment">//-移除 PTE 时，设置 TLB 无效。</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">page_remove(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pde_t</span> *pte;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span> =</span> page_lookup(pgdir, va, &amp;pte);</span><br><span class="line">    <span class="keyword">if</span> ((*pte &amp; PTE_P) &amp;&amp; pp) &#123;</span><br><span class="line">		page_decref(pp);</span><br><span class="line">		*pte = <span class="number">0</span>;</span><br><span class="line">		tlb_invalidate(pgdir, va);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="page-insert"><a href="#page-insert" class="headerlink" title="page_insert()"></a>page_insert()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现物理页 &#x27;pp&#x27; 到虚拟地址 &#x27;va&#x27; 的映射。</span></span><br><span class="line"><span class="comment">//页表条目的权限为设置为 &#x27;perm|PTE_P&#x27;。</span></span><br><span class="line"><span class="comment">//要求：</span></span><br><span class="line"><span class="comment">//-如果 &#x27;va&#x27; 处已经有页面映射，应当被 page_remove;</span></span><br><span class="line"><span class="comment">//-必要的话，应当分配页表并插入到 &#x27;pgdir&#x27;;</span></span><br><span class="line"><span class="comment">//-如果插入成功，pp-&gt;pp_ref 应当递增；</span></span><br><span class="line"><span class="comment">//-如果页面以前存在于 &#x27;va&#x27; 中， 则 TLB 必须失效。</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">page_insert(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)&#123;</span><br><span class="line">	<span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	pp-&gt;pp_ref++;</span><br><span class="line">	<span class="keyword">if</span> (*pte &amp; PTE_P) &#123;</span><br><span class="line">		page_remove(pgdir, va);</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	*pte = page2pa(pp) | perm | PTE_P;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h2><p>JOS 将处理器的 32 位线性地址空间分为两部分。我们将在 lab 3 中开始加载和运行的用户环境（进程）将控制下半部分的布局和内容，而内核始终保持对上半部分的完全控制。分隔线由 inc/memlayout.h 中的符号 ULIM 任意定义，为内核保留大约 256MB 的虚拟地址空间。这解释了为什么我们需要在 lab 1 中给内核提供如此高的链接地址：否则内核的虚拟地址空间中没有足够的空间同时在内核下面的用户环境中映射。对于此部分和以后的 lab，在 inc/memlayout.h 中引用 JOS 内存布局图会很有帮助。</p>
<h3 id="Permissions-and-Fault-Isolation"><a href="#Permissions-and-Fault-Isolation" class="headerlink" title="Permissions and Fault Isolation"></a>Permissions and Fault Isolation</h3><p>由于内核和用户内存都存在于每个环境的地址空间中，因此我们必须使用 x86 页表中的权限位，以允许用户代码仅访问地址空间的用户部分。否则，用户代码中的 Bug 可能会覆盖内核数据，导致崩溃或更细微的故障；用户代码也可能窃取其他环境的私有数据。请注意，可写权限位（PTE_W）同时影响用户和内核代码！</p>
<p>用户环境将没有权限访问 ULIM 以上的任何内存，而内核将能够读取和写入此内存。对于地址范围 [UTOP，ULIM），内核和用户环境具有相同的权限：它们可以读取但无法写入此地址范围。此地址范围用于向用户环境公开某些只读的内核数据结构。最后，UTOP 下面的地址空间供用户环境使用；用户环境将设置访问此内存的权限。</p>
<h3 id="Initializing-the-Kernal-Address-Space"><a href="#Initializing-the-Kernal-Address-Space" class="headerlink" title="Initializing the Kernal Address Space"></a>Initializing the Kernal Address Space</h3><p>现在，您将设置 UTOP 上方的地址空间：地址空间的内核部分。inc/memlayout.h 显示了您应该使用的布局。您将使用刚刚写的函数来设置适当的线性地址到物理地址的映射。</p>
<h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5."></a>Exercise 5.</h4><blockquote>
<p>补全 mem_init() 中缺失的代码。使 <code>check_kern_pgdir()</code> 和 <code>check_page_installed_pgdir()</code> 通过。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">men_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    check_page();</span><br><span class="line">    <span class="comment">// 现在设置虚拟内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在线性地址 UPAGES 上映射用户只读的 &#x27;pages&#x27;。</span></span><br><span class="line">    <span class="comment">// 权限：</span></span><br><span class="line">    <span class="comment">//  -UPAGES 的新映像 --kernel R, user R</span></span><br><span class="line">    <span class="comment">//     (ie. perm = PTE_U|PTE_P)</span></span><br><span class="line">    <span class="comment">//  -pages 本身 --kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    boot_map_region(kern_pgdir, UPAGES, PTSIZE, </span><br><span class="line">                    PADDR(pages), PTE_W);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 &#x27;bootstack&#x27; 指向的物理内存作为内核栈。内核栈从虚拟</span></span><br><span class="line">    <span class="comment">// 地址 KSTACKTOP 处向下扩展。我们认为从 </span></span><br><span class="line">    <span class="comment">// [KSTACKTOP-PTSIZE，KSTACKTOP）的整个范围是内核堆栈，但</span></span><br><span class="line">    <span class="comment">// 将它分成两部分：</span></span><br><span class="line">    <span class="comment">//  *[KSTACKTOP-KSTKSIZE, KSTACKTOP) --由物理内存备份</span></span><br><span class="line">    <span class="comment">//  *[KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) --不备份;</span></span><br><span class="line">    <span class="comment">//   因此，如果内核溢出其堆栈，它将故障而不是覆盖内存。称为&quot;保</span></span><br><span class="line">    <span class="comment">//   护页&quot;。</span></span><br><span class="line">    <span class="comment">//  Permissions: kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    </span><br><span class="line">    boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, </span><br><span class="line">                    KSTKSIZE, PADDR(bootstack), PTE_U);</span><br><span class="line">    <span class="comment">// 映射 KERNBASE 处的所有物理内存。</span></span><br><span class="line">    <span class="comment">// 即：[KERNBASE, 2^32) 之间的 VA 应当映射到 [0, 2^32 - </span></span><br><span class="line">    <span class="comment">// KERNBASE) 之间的 PA。</span></span><br><span class="line">    <span class="comment">// 我们可能没有 2^32 - KERNBASE 字节的物理内存，但我们还是只</span></span><br><span class="line">    <span class="comment">// 设置了映射。</span></span><br><span class="line">    <span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line">	<span class="comment">// Your code goes here:</span></span><br><span class="line">    boot_map_region(kern_pgdir, KERNBASE, - KERNBASE, <span class="number">0</span>, </span><br><span class="line">                    PTE_W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h4><ol start="2">
<li><p>此时页目录中的哪些条目（行）已填写？它们映射哪些地址，它们指向哪里？换句话说，请尽可能多地填写此表：</p>
<table>
<thead>
<tr>
<th align="center">entry</th>
<th>base Va</th>
<th>Points to (logically):</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1023</td>
<td></td>
<td>Page table for top 4MB of phys memory</td>
</tr>
<tr>
<td align="center">1022</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">…</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">…</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">2</td>
<td>0x00800000</td>
<td></td>
</tr>
<tr>
<td align="center">1</td>
<td>0x00400000</td>
<td></td>
</tr>
<tr>
<td align="center">0</td>
<td>0x00000000</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>我们已将内核和用户环境放在同一个地址空间中。为什么用户程序不能读取或写入内核的内存？哪些特定机制保护内核内存？</p>
<blockquote>
<p>如果应用程序能够读取写入内核的内存，那么内核的安全性将无法保证。</p>
<p>内核内存的页表项的 perm 的  PTE_U 位未设置，那么应用程序访问这些内存时将会因为权限不够而报错。</p>
</blockquote>
</li>
<li><p>此操作系统可以支持的最大物理内存量是多少？为什么？</p>
<blockquote>
<p>1024 * 1024 * 4096 B = 4 GB</p>
</blockquote>
</li>
<li><p>如果我们实际上拥有最大的物理内存，管理内存的空间开销有多少？这个开销是怎么分解的？</p>
<blockquote>
<p>管理内存的开销 为 页目录  + 页表  +  的开销</p>
<p>页目录： 1024 * 4 B＝ 4096 B = 4 KB</p>
<p>页表： 1024 * 1024 * 4 B = 4 MB </p>
<p>PagesInfo Struct ： （4B + 2B）* 1024* 1024 = 6 MB</p>
</blockquote>
</li>
<li><p>重新查看 <code>kern/entry.S</code> 和 <code>kern/entrypgdir.c</code> 中的页表设置。开启分页后，EIP 仍然是一个较低的数字（超过 1MB）。在哪里转换到 KERNBASE 以上的 EIP 运行？从启用分页和开始在 KERNBASE 以上的 EIP 上运行之间，如何才能继续以低 EIP 执行？为什么这种过渡是必要的？</p>
</li>
</ol>
<h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><p>我们使用许多物理页来保存 KERNBASE 映射的页表。使用页目录条目中的 PTE_PS（”Page Size”）位，进行更节省空间的工作。原始 80386 不支持此位，但最近的 x86 处理器支持。因此，您必须参考 <a href="../../readings/ia32/IA32-3A.pdf">Volume 3 of the current Intel manuals</a>。请确保将内核设计为仅在支持该优化的处理器上使用此优化！</p>
<p>扩展 JOS 内核监视器的命令：</p>
<ul>
<li>以有用且易于阅读的格式显示应用于当前活动地址空间中特定范围的虚拟/线性地址的所有物理页面映射（或缺少这些映射）。例如，您可以输入 ‘showmappings 0x3000 0x5000’ 以显示应用于虚拟地址 0x3000、0x4000 和 0x5000 的页面的物理页面映射和相应的权限位。</li>
<li>显式设置、清除或更改当前地址空间中任何映射的权限。</li>
<li>转储给定虚拟或物理地址范围的内存范围的内容。当范围跨页面边界扩展时，请确保转储代码行为正确！</li>
<li>实现您认为以后对调试内核可能有用的其他操作。</li>
</ul>
<h3 id="Address-Space-Layout-Alternatives"><a href="#Address-Space-Layout-Alternatives" class="headerlink" title="Address Space Layout Alternatives"></a>Address Space Layout Alternatives</h3><p>我们在 JOS 中使用的地址空间布局并并非唯一可能。操作系统可能会在低线性地址映射内核，同时将线性地址的上部留给用户进程。但是，x86 内核通常不采用此方法，因为 x86 的向后兼容性模式之一（称为虚拟 8086 模式）在处理器中是”硬连线”，使用线性地址空间的底部，因此如果内核映射在那里，则根本无法使用。</p>
<p>那是可能的（尽管困难的多），设计内核时，不必为自己的固定部分保留处理器任何线性或虚拟地址空间，而是有效地允许用户级进程不受限制地使用整个 4GB 的虚拟地址空间 - 同时仍然完全保护内核免受这些进程的影响，并保护不同的进程免受彼此的影响！</p>
<h4 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge"></a>Challenge</h4><p>1.每个用户级环境映射内核。更改 JOS，以便内核有自己的页表，并且用户级环境运行时映射的内核页数最少。也就是说，每个用户级环境映射的页面都仅仅满足用户级环境可以正确进入和离开内核。您还必须为内核制定一个计划，以读取/写入系统调用的参数。</p>
<p>2.编写设计 内核如何允许用户环境不受限制地使用完整的 4GB 虚拟和线性地址空间的大纲。</p>
<ul>
<li>提示：首先完成上一个挑战练习，这将内核减少为用户环境中的一些映射。</li>
<li>提示：该技术有时称为 ‘<em>follow the bouncing kernel</em>‘。</li>
</ul>
<p>在设计中，请务必确切地解决处理器在内核和用户模式之间转换时必须发生哪些操作，以及内核如何完成此类转换。还要描述内核如何访问此方案中的物理内存和 I/O 设备，以及内核在系统调用等期间如何访问用户环境的虚拟地址空间。最后，从灵活性、性能、内核复杂性和您想到的其他因素的角度思考并描述这种方案的优缺点。</p>
<p>3.由于我们的JOS内核的内存管理系统只分配和释放页面粒度上的内存，因此我们没有任何可以在内核内使用的与通用 malloc/free 相媲美的设施。如果我们想要支持某些类型的 I/O 设备，这些设备需要大于 4KB 的物理连续缓冲区，或者我们希望用户级环境（而不仅仅是内核）能够分配和映射 4MB 超页面以最大限度地提高处理器效率，则这可能是个问题（查看早期有关 “PTE_P” 的挑战问题）。</p>
<p>将内核的内存分配系统概括为支持从 4KB 到您选择的合理最大值的各种双电源分配单元大小的页面。请确保有一定的方法按需将较大的分配单位划分为较小的分配单位，并在可能的情况下将多个小型分配单位并入更大的分配单位。思考这样一个系统中可能出现的问题。</p>
]]></content>
  </entry>
  <entry>
    <title>Lab 5: 文件系统</title>
    <url>/2020/12/02/lab5/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在这个实验中，您将实现 spawn，一个加载并在磁盘可执行文件上运行的库调用。然后，您将充实您的内核和库操作系统，足以在控制台上运行 shell。这些特性需要一个文件系统，本实验室介绍了一个简单的 读/写 文件系统。</p>
<h1 id="File-system-preliminaries"><a href="#File-system-preliminaries" class="headerlink" title="File system preliminaries"></a>File system preliminaries</h1><p>您将使用的文件系统比大多数 “真实” 的文件系统（包括 xv6 unix）简单得多，但它的功能足以提供基本功能：创建、读取、写入和删除以分层目录结构组织的文件。</p>
<p>我们目前（无论如何）只开发一个单用户操作系统，它提供足够的保护来捕捉错误，但不能保护多个相互怀疑的用户。因此，我们的文件系统不支持 UNIX 文件所有权或权限的概念。我们的文件系统目前也不支持硬链接、符号链接、时间戳或像大多数 UNIX 文件系统那样的特殊设备文件。</p>
<a id="more"></a>

<h2 id="1-1-On-Disk-File-System-Structure"><a href="#1-1-On-Disk-File-System-Structure" class="headerlink" title="1. 1 On-Disk File System Structure"></a>1. 1 On-Disk File System Structure</h2><p>大多数 UNIX 文件系统将可用磁盘空间分为两种主要类型的区域：inode 区域和数据区域。UNIX 文件系统为文件系统中的每个文件分配一个 inode；文件的 inode 保存有关文件的关键元数据，例如其 stat 属性和指向其数据块的指针。数据区域被划分成更大的（通常是 8KB 或更多）数据块，文件系统在其中存储文件数据和目录元数据。目录条目包含文件名和索引节点的指针；如果文件系统中的多个目录条目引用了该文件的 inode，则该文件被称为硬链接。由于我们的文件系统不支持硬链接，因此我们不需要这种级别的间接寻址，因此可以方便地简化：我们的文件系统根本不使用 inode，而是将一个文件（或子目录）的所有元数据存储在描述该文件的（唯一的）目录项中。</p>
<p>文件和目录在逻辑上都由一系列数据块组成，这些数据块可能分散在磁盘上，就像环境的虚拟地址空间的页面可以分散在物理内存中一样。文件系统环境隐藏了块布局的细节，提供了在文件中以任意偏移量读取和写入字节序列的接口。作为执行文件创建和删除等操作的一部分，文件系统环境在内部处理对目录的所有修改。我们的文件系统允许用户环境直接读取目录元数据（例如，使用 read），这意味着用户环境可以自己执行目录扫描操作（例如，实现 ls 程序），而不必依赖对文件系统的额外特殊调用。这种目录扫描方法的缺点，也是大多数现代 UNIX 变体不鼓励它的原因，是它使应用程序依赖于目录元数据的格式，使得在不更改或至少重新编译应用程序的情况下很难更改文件系统的内部布局。</p>
<h3 id="Sectors-and-Blocks"><a href="#Sectors-and-Blocks" class="headerlink" title="Sectors and Blocks"></a>Sectors and Blocks</h3><p>大多数磁盘不能以字节粒度执行读写操作，而是以扇区为单位执行读写操作。在 JOS 中，每个扇区是 512 字节。文件系统实际上以块为单位分配和使用磁盘存储。请注意这两个术语之间的区别：扇区大小是磁盘硬件的属性，而块大小是使用磁盘的操作系统的一个方面。文件系统的块大小必须是基础磁盘扇区大小的倍数。</p>
<p>UNIX xv6 文件系统使用 512 字节的块大小，与底层磁盘的扇区大小相同。然而，大多数现代文件系统使用更大的块大小，因为存储空间已经变得更便宜，并且在更大粒度上管理存储更有效。我们的文件系统将使用 4096 字节的块大小，方便地匹配处理器的页面大小。</p>
<h3 id="Superblocks"><a href="#Superblocks" class="headerlink" title="Superblocks"></a>Superblocks</h3><p>文件系统通常在磁盘上“易于查找”的位置（例如最开始或最末尾）保留某些磁盘块，以保存描述文件系统整体属性的元数据，例如块大小、磁盘大小、查找根目录所需的任何元数据、文件系统上次装入的时间、文件的时间最后一次检查系统是否有错误，等等。这些特殊的块称为超级块。</p>
<p>我们的文件系统正好有一个超级块，它总是在磁盘上的块 1 上。它的布局由inc/fs.h 中的 struct Super 定义。块 0 通常被保留用来存放引导加载程序和分区表，因此文件系统通常不使用第一个磁盘块。许多“真正的”文件系统维护多个超级块，这些超级块复制到磁盘的多个间隔较远的区域，因此，如果其中一个超级块已损坏或磁盘在该区域出现介质错误，则仍可以找到其他超级块并使用它们访问文件系统。</p>
<h3 id="File-Meta-data"><a href="#File-Meta-data" class="headerlink" title="File Meta-data"></a>File Meta-data</h3><p>文件系统中描述文件的元数据布局由 inc/fs.h 中的 struct file 描述。这些元数据包括文件名、大小、类型（常规文件或目录）以及指向组成文件的块的指针。如上所述，我们没有索引节点，所以这些元数据存储在磁盘上的目录项中。与大多数“真实”的文件系统不同，为了简单起见，我们将使用这个单一的文件结构来表示文件元数据，因为它既出现在磁盘上，也出现在内存中。</p>
<p>struct 文件中的 f_direct 数组包含存储文件前 10 个（NDIRECT）块的块号的空间，我们称之为文件的直接块。对于大小不超过 10*4096 = 40KB 的小文件，这意味着所有文件块的块号将直接适合于文件结构本身。但是，对于较大的文件，我们需要一个存放文件其余块号的位置。因此，对于任何大于 40KB 的文件，我们分配一个额外的磁盘块，称为文件的间接块，以容纳 4096/4 = 1024 个额外的块号。因此，我们的文件系统允许文件的大小达到 1034 个块，或者刚好超过 4 M 字节。为了支持更大的文件，“真正的”文件系统通常也支持两个和三个间接块。</p>
<p><img src="C:\Users\dier\Pictures\file.png" alt="file"></p>
<p><img src="C:\Users\dier\Pictures\disk.png" alt="disk"></p>
<h3 id="Directories-versus-Regular-Files"><a href="#Directories-versus-Regular-Files" class="headerlink" title="Directories versus Regular Files"></a>Directories versus Regular Files</h3><p>文件系统中的文件结构可以表示常规文件或目录；这两种类型的“文件”通过 file 结构中的 type 字段来区分。文件系统以完全相同的方式管理常规文件和目录文件，只是它根本不解释与常规文件相关联的数据块的内容，而文件系统将目录文件的内容解释为一系列描述目录中文件和子目录的文件结构。</p>
<p>文件系统中的 superblock 包含一个文件结构（struct Super 中的 root 字段），它保存文件系统根目录的元数据。这个目录文件的内容是一系列文件结构，描述文件系统根目录中的文件和目录。根目录中的任何子目录都可能包含更多表示子目录的文件结构，依此类推。</p>
<h1 id="The-File-System"><a href="#The-File-System" class="headerlink" title="The File System"></a>The File System</h1><p>本 Lab 的目标不是让您实现整个文件系统，而是让您只实现某些关键组件。特别是，您将负责将块读入块缓存并将其刷新回磁盘；分配磁盘块；将文件偏移量映射到磁盘块；在 IPC 接口中实现读、写、打开。因为您不会自己实现所有的文件系统，所以您必须熟悉所提供的代码和各种文件系统接口。</p>
<h2 id="2-1-Disk-Access"><a href="#2-1-Disk-Access" class="headerlink" title="2.1 Disk Access"></a>2.1 Disk Access</h2><p>我们操作系统中的文件系统环境需要能够访问磁盘，但是我们还没有在内核中实现任何磁盘访问功能。我们没有采用传统的 “单片” 操作系统策略，即在内核中添加 IDE 磁盘驱动程序以及允许文件系统访问它的必要系统调用，而是将 IDE 磁盘驱动程序作为用户级文件系统环境的一部分来实现。我们仍然需要稍微修改内核，以便进行设置，使文件系统环境具有实现磁盘访问本身所需的权限。</p>
<p>只要我们依靠轮询、“编程I/O”（programmed I/O，PIO）为基础的磁盘访问，并且不使用磁盘中断，这种方式很容易在用户空间中实现磁盘访问。也可以在用户模式下实现中断驱动的设备驱动程序（例如，L3 和 L4 内核就可以实现），但由于内核必须将设备中断字段化并将其分派到正确的用户模式环境中，所以难度更大。</p>
<p>x86 处理器使用 EFLAGS 寄存器中的 IOPL 位来确定是否允许保护模式代码执行特殊的设备 I/O 指令，如输入和输出指令。由于我们需要访问的所有 IDE 磁盘寄存器都位于 x86 的 I/O 空间中，而不是内存映射，因此，为文件系统环境提供 “I/O 特权” 是我们唯一需要做的事情，以便允许文件系统访问这些寄存器。实际上，EFLAGS 寄存器中的 IOPL 位为内核提供了一种简单的“全有或全无”的方法来控制用户模式代码是否可以访问 I/O 空间。在我们的例子中，我们希望文件系统环境能够访问 I/O 空间，但是我们根本不希望任何其他环境能够访问 I/O 空间。</p>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1."></a>Exercise 1.</h4><p>i386_init 通过将类型 ENV_TYPE_FS 传递给环境创建函数 env_create 来标识文件系统环境。在 env.c 中修改 env_create，使其赋予文件系统环境 I/O 权限，但不会将该特权授予任何其他环境。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If this is the file server (type == ENV_TYPE_FS) give </span></span><br><span class="line"><span class="comment">// it I/O privileges.</span></span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (type == ENV_TYPE_FS) &#123;</span><br><span class="line">	e-&gt;env_tf.tf_eflags = e-&gt;env_tf.tf_eflags | </span><br><span class="line">            							FL_IOPL_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h4><p>当您随后从一个环境切换到另一个环境时，您还需要做其他任何事情来确保这个 I/O 特权设置被正确保存和恢复吗？为什么？</p>
<p>注意，这个 lab 中的 GNUmakefile 文件设置 QEMU 以使用文件 obj/kern/kernal.img 作为磁盘 0 的映像（通常是 DOS/Windows下 的“驱动器 C”），并使用（新）文件 obj/fs/fs.img 作为磁盘 1（“驱动器 D”）的映像。在这个 lab 中，我们的文件系统应该只接触磁盘 1；磁盘 0 只用于引导内核。如果您设法以某种方式损坏了其中一个磁盘映像，则只需键入以下命令即可将它们重置为原始的“原始”版本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ rm obj/kern/kernel.img obj/fs/fs.img</span><br><span class="line">$ make</span><br><span class="line"><span class="keyword">or</span> by doing:</span><br><span class="line">$ make clean</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>

<h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>实现中断驱动的 IDE 磁盘访问，有或没有 DMA。您可以决定是否将设备驱动程序移到内核中，将其与文件系统一起保留在用户空间中，或者甚至（如果您真的想深入了解微内核精神）将其移动到一个单独的环境中。</p>
<h2 id="2-2-The-Block-Cache"><a href="#2-2-The-Block-Cache" class="headerlink" title="2.2 The Block Cache"></a>2.2 The Block Cache</h2><p>在我们的文件系统中，我们将在处理器的虚拟内存系统的帮助下实现一个简单的“缓冲缓存”（实际上只是一个块缓存）。块缓存的代码在 fs/bc.c 中。</p>
<p>我们的文件系统只能处理 3GB 或更小的磁盘。我们在文件系统环境的地址空间中保留一个大的、固定的 3GB 区域，从 0x10000000（DISKMAP）到0xd000000（DISKMAP+DISKMAX），作为磁盘的“内存映射”版本。例如，磁盘块 0 映射到虚拟地址 0x10000000，磁盘块1映射到虚拟地址 0x10001000，依此类推。fs/bc.c 中的 diskaddr 函数实现了从磁盘块号到虚拟地址的转换（以及一些健全性检查）。</p>
<p>由于我们的文件系统环境有自己的虚拟地址空间，独立于系统中所有其他环境的虚拟地址空间，而且文件系统环境只需要实现文件访问，因此以这种方式保留大部分文件系统环境的地址空间是合理的。对于 32 位计算机上的实际文件系统实现来说，这样做会很尴尬，因为现代磁盘大于 3GB。在具有 64 位地址空间的机器上，这样的缓冲区缓存管理方法可能仍然是合理的。</p>
<p>当然，将整个磁盘读入内存需要很长时间，因此我们将实现一种按需分页的形式，在这种情况下，我们只在磁盘映射区域中分配页，并在该区域中出现页面错误时从磁盘读取相应的块。这样，我们可以假装整个磁盘都在内存中。</p>
<h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2."></a>Exercise 2.</h4><p>在 fs/bc.c 中实现 bc_gfault 和 flush_block 函数。bc_pgfault 是一个页面错误处理程序，与您在上一个实验室中为“写入时复制”fork编写的处理程序一样，只是它的工作是在出现页错误时从磁盘加载页。在编写时，请记住（1）addr 可能不与块边界对齐，（2）ide_read 在扇区而不是块中操作。</p>
<p>如有必要，flush_block 函数应将块写入磁盘。如果块甚至不在块缓存中（也就是说，页面没有被映射）或者它不是脏的，flush_block 不应该做任何事情。我们将使用 VM 硬件来跟踪自上次从磁盘读取或写入磁盘以来，磁盘块是否已被修改。为了查看一个块是否需要写入，我们只需查看是否在 uvpt 条目中设置了 PTE_D “dirty” 位。（PTE_D 位由处理器设置，以响应对该页的写入；参见 386 参考手册第 5 章的 5.2.4.3。）将块写入磁盘后，flush_block  应使用 sys_page_map 清除 PTE_D 位。</p>
<p>使用 check_bc, check_super, check_bitmap 检查。</p>
<p>fs/fs.c 中的 fs_init 函数是如何使用块缓存的一个主要示例。初始化块缓存后，它只需将指针存储到超级全局变量中的磁盘映射区域中。在这之后，我们可以像在内存中一样简单地从超级结构中读取它们，我们的页面错误处理程序将根据需要从磁盘读取它们。</p>
<h4 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>块缓存没有逐出策略。一旦一个块出错，它就永远不会被移除，并将永远留在内存中。将逐出添加到缓冲区缓存。使用页表中的 PTE_A “accessed” 位（硬件在访问页面时设置该位），您可以跟踪磁盘块的大致使用情况，而无需修改访问磁盘映射区域的代码中的每个位置。小心脏块。</p>
<h2 id="2-3-The-Block-Bitmap"><a href="#2-3-The-Block-Bitmap" class="headerlink" title="2.3 The Block Bitmap"></a>2.3 The Block Bitmap</h2><p>在 fs_init 设置位图指针后，我们可以将 位图 视为压缩的位数组，磁盘上的每个块对应一个。例如，请参见 block_is_free，它只检查给定块在位图中是否标记为free。</p>
<h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3."></a>Exercise 3.</h4><p>使用 free_block 作为模型在 fs/fs.c 中实现 alloc_block，它应该在位图中找到一个空闲磁盘块，将其标记为 used，并返回该块的编号。分配块时，应立即使用 flush_block 将更改的位图块刷新到磁盘，以帮助文件系统的一致性。</p>
<p>通过 alloc_block。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">111</span>; i &lt; super-&gt;s_nblocks; i++) &#123;</span><br><span class="line">		<span class="keyword">bool</span> r = block_is_free(i);</span><br><span class="line">		<span class="keyword">if</span> (r) &#123;</span><br><span class="line">			bitmap[i / <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (i % <span class="number">32</span>));</span><br><span class="line">			flush_block(diskaddr(i));</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -E_NO_DISK;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-File-Operations"><a href="#2-4-File-Operations" class="headerlink" title="2.4 File Operations"></a>2.4 File Operations</h2><p>我们在 fs/fs.c 中提供了多种函数来实现基本功能，您将需要这些功能来解释和管理文件结构、扫描和管理目录文件的条目，以及从根目录遍历文件系统以解析绝对路径名。在继续之前，请通读 fs/fs.c 中的所有代码，并确保理解每个函数的作用。</p>
<h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4."></a>Exercise 4.</h4><p>实现 <code>file_block_walk</code> and <code>file_get_block</code>。file_block_walk 从文件中的块偏移量映射到结构文件或间接块中该块的指针，非常类似于 pgdir_walk 对页表所做的操作。file_get_block 更进一步，映射到实际的磁盘块，如果需要，会分配一个新的。</p>
<p>file_block_walk 和 file_get_block 是文件系统的 workhorses。例如，file_read 和 file_write 只不过是在分散的块和顺序缓冲区之间复制字节所必需的文件块之上的簿记。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">file_block_walk(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">uint32_t</span> **ppdiskbno, <span class="keyword">bool</span> alloc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;file_block_walk not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">if</span> (filebno &gt;= NDIRECT + NINDIRECT) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (filebno &lt; NDIRECT) &#123;</span><br><span class="line">		*ppdiskbno = &amp;(f-&gt;f_direct[filebno]);  </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!f-&gt;f_indirect) &#123;</span><br><span class="line">			<span class="keyword">if</span> (alloc) &#123;</span><br><span class="line">				<span class="keyword">uint32_t</span> r = alloc_block();</span><br><span class="line">				<span class="keyword">if</span>( r == -E_NO_DISK) &#123;</span><br><span class="line">					<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">memset</span>(diskaddr(r), <span class="number">0</span>, PGSIZE);</span><br><span class="line">				f-&gt;f_indirect = r;</span><br><span class="line">				flush_block(diskaddr(r));</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		*ppdiskbno = (<span class="keyword">uint32_t</span> *)diskaddr(f-&gt;f_indirect) + filebno - NDIRECT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">file_get_block(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">char</span> **blk)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;file_get_block not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">uint32_t</span> *ppdiskbno;</span><br><span class="line">	<span class="keyword">int</span> r = file_block_walk(f, filebno, &amp;ppdiskbno, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (r) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (*ppdiskbno == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">		*ppdiskbno = r;</span><br><span class="line">		<span class="built_in">memset</span>(diskaddr(r), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">		flush_block(diskaddr(r));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	*blk = diskaddr(*ppdiskbno);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>如果文件系统在操作过程中被中断（例如，崩溃或重新启动），则文件系统可能已损坏。实现软更新或日志记录，使文件系统具有抗崩溃能力，并演示旧文件系统可能会损坏，但您的文件系统不会损坏的情况。</p>
<h2 id="2-5-The-file-system-interface"><a href="#2-5-The-file-system-interface" class="headerlink" title="2.5 The file system interface"></a>2.5 The file system interface</h2><p>既然我们在文件系统环境本身中拥有了必要的功能，那么我们必须使希望使用该文件系统的其他环境能够访问它。由于其他环境不能直接调用文件系统环境中的函数，我们将通过构建在 JOS 的 IPC 机制之上的远程过程调用（RPC）来公开对文件系统环境的访问。从图形上看，下面是对文件系统服务器（比如说，read）的调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      Regular env           FS env</span><br><span class="line">   +---------------+   +---------------+</span><br><span class="line">   |      read     |   |   file_read   |</span><br><span class="line">   |   (lib/fd.c)  |   |   (fs/fs.c)   |</span><br><span class="line">...|.......|.......|...|.......^.......|...............</span><br><span class="line">   |       v       |   |       |       | RPC mechanism</span><br><span class="line">   |  devfile_read |   |  serve_read   |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^    	   |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |     fsipc     |   |     serve     |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |   ipc_send    |   |   ipc_recv    |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   +-------|-------+   +-------|-------+</span><br><span class="line">           |                   |</span><br><span class="line">           +-------------------+</span><br></pre></td></tr></table></figure>

<p>虚线以下的所有内容都是从常规环境向文件系统环境获取读取请求的机制。从一开始，read（我们提供的）在任何文件描述符上工作，并简单地将其分派到适当的设备读取函数，在本例中，devfile_read（我们可以有更多的设备类型，比如管道）。devfile_read 实现了专门针对磁盘上文件的读取。这个函数和 lib/file.c 中的其他 devfile_* 函数实现了 FS 操作的客户端，并且它们的工作方式大致相同，将参数绑定到请求结构中，调用 fsipc 发送 IPC 请求，并解包并返回结果。fsipc 函数只处理向服务器发送请求和接收应答的常见细节。</p>
<p>文件系统服务器代码可以在 fs/serv.c 中找到。它在 serve 函数中循环，通过 IPC 无休止地接收一个请求，将该请求发送给适当的处理函数，并通过 IPC 将结果发送回来。在 read 示例中，serve 将分派到 serve_read，它将处理特定于读取请求的 IPC 细节，例如解包请求结构，最后调用 file_read 来实际执行文件读取。</p>
<p>回想一下 JOS 的 IPC 机制允许环境发送一个 32 位的数字，并且可以选择共享一个页面。为了从客户机向服务器发送请求，我们使用 32 位数字作为请求类型（文件系统服务器 RPC 是编号的，就像 syscalls 的编号方式一样），并将请求的参数存储在通过 IPC 共享的页面上的 union Fsipc 中。在客户端，我们总是在 fsipcbuf 共享页面；在服务器端，我们将传入的请求页面映射到 fsreq（0x0ffffff000）。</p>
<p>服务器也通过 IPC 发送响应。我们使用 32 位数字作为函数的返回码。对于大多数 rpc 来说，这就是它们返回的全部内容。FSREQ_READ 和 FSREQ_STAT 也返回数据，它们只是将数据写入客户机发送请求的页面。不需要在响应 IPC 中发送此页面，因为客户机首先将其与文件系统服务器共享。另外，在其响应中， FSREQ_OPEN 与客户机共享一个新的 “Fd page”。我们将很快返回文件描述符页面。</p>
<h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5."></a>Exercise 5.</h4><p>在 fs/serv.c 中实现 serve_read。</p>
<p>serve_read 的繁重工作将由已经在 fs/fs.c 中实现的 file_read 完成（这反过来，它只是对 file_get_block 的一系列调用）。serve_read 只需为文件读取提供 RPC 接口。查看 serve_set_size 中的注释和代码，了解服务器功能应该如何构建。</p>
<p>Use <em>make grade</em> to test your code. Your code should pass “<em>serve_open/file_stat/file_clos</em>e” and “file_read” for a score of 70/150.</p>
<h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6."></a>Exercise 6.</h4><p>在 fs/serv.c 中实现 serve_write，在 lib/file.c 中实现 devfile_write。</p>
<p>Use <em>make grade</em> to test your code. Your code should pass “<em>file_write</em>“, “<em>file_read</em> <em>after file_write</em>“, “<em>open</em>“, and “<em>large file</em>“ for a score of 90/150.</p>
<h1 id="Spawning-Processes"><a href="#Spawning-Processes" class="headerlink" title="Spawning Processes"></a>Spawning Processes</h1><p>我们已经给出了 spawn 的代码（参见 lib/spawn.c），它创建了一个新环境，将程序映像从文件系统加载到其中，然后启动运行该程序的子环境。然后，父进程继续独立于子进程运行。spawn 函数实际上就像 UNIX 中的 fork，然后是子进程中的立即 exec。</p>
<p>我们实现了 spawn 而不是 UNIX 风格的 exec，因为 spawn 更容易从用户空间以 “exokernel fashion” 实现，而无需内核的特殊帮助。想一想，为了在用户空间中实现 exec，您必须做些什么，并确保您理解为什么这样做比较困难。</p>
<h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7."></a>Exercise 7.</h4><p>spawn 依赖于新的 syscall sys_env_set_trapframe 来初始化新创建的环境的状态。在 kern/syscall.c 中实现 sys_env_set_trapframe（不要忘记在 syscall（）中分派新的系统调用）。</p>
<p>通过从 kern/init.c 运行 user/spawnhello 程序来测试代码，该程序将尝试从文件系统派生  /hello。</p>
<p>Use <em>make grade</em> to test your code.</p>
<h4 id="Challenge-3"><a href="#Challenge-3" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>Implement Unix-style <code>exec</code>.</p>
<h4 id="Challenge-4"><a href="#Challenge-4" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>Implement <code>mmap</code>-style memory-mapped files and modify <code>spawn</code> to map pages directly from the ELF image when possible.</p>
<h2 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h2><p>UNIX 文件描述符是一个通用的概念，它还包括管道、控制台 I/O 等。在 JOS 中，这些设备类型中的每一种都有一个对应的 struct Dev，其中包含指向为该设备类型实现读/写等功能的指针。lib/fd.c 在此基础上实现了通用的类 UNIX 文件描述符接口。每个 struct Fd 都表示它的设备类型，lib/fd.c 中的大多数函数只是将操作分派到适当的 struct Dev 中的函数。</p>
<p>lib/fd.c 还从 FDTABLE 开始在每个应用程序环境的地址空间中维护文件描述符表区域。这个区域为应用程序可以同时打开的每个文件描述符保留一个页面（4KB）的地址空间。在任何给定的时间，当且仅当相应的文件描述符正在使用时，才会映射特定的文件描述符表页。每个文件描述符在从 FILEDATA 开始的区域中还有一个可选的“数据页”，如果设备愿意，可以使用它。</p>
<p>我们希望在 fork 和 spawn 之间共享文件描述符状态，但文件描述符状态保存在用户空间内存中。现在，在 fork 上，内存将被标记为 copy-on-write，因此状态将被复制而不是共享。（这意味着环境将无法在自己未打开的文件中查找，管道也无法跨越 fork 工作。）在生成时，内存将被留下，而不是被复制。（实际上，生成的环境从没有打开的文件描述符开始。）</p>
<p>我们将更改 fork 以了解内存的某些区域由“库操作系统”使用，并且应该始终共享。我们不必在某个地方硬编码区域列表，而是在页表条目中设置一个未使用的位（就像我们在 fork 中使用 PTE_COW 位一样）。</p>
<p>我们在 inc/lib.h 中定义了一个新的 PTE_SHARE。此位是 Intel 和 AMD 手册中标记为“可供软件使用”的三个 PTE 位之一。我们将建立这样一个约定：如果一个页表条目有这个位集，那么 PTE 应该在 fork 和 spawn 中直接从父项复制到子项。请注意，这与将其标记为“写入时复制”不同：如第一段所述，我们希望确保共享页面的更新。</p>
<h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8."></a>Exercise 8.</h4><p>在 lib/fork.c 中更改 duppage 以遵循新的约定。如果页表条目设置了 PTE_SHARE 位，只需直接复制映射。（应该使用 PTE_SYSCALL 而不是 0xff来屏蔽页表项中的相关位。0xfff 也会获取访问的和脏的位。）同样，在 lib/spawn.c 中实现copy_shared_pages。它应该遍历当前进程中的所有页表条目（就像 fork 一样），将所有设置了 PTE_SHARE 位的页映射复制到子进程中。</p>
<p>Use make run-testpteshare to check that your code is behaving properly. You should see lines that say “<code>fork handles PTE_SHARE right</code>“ and “<code>spawn handles PTE_SHARE right</code>“.</p>
<p>Use make run-testfdsharing to check that file descriptors are shared properly. You should see lines that say “<code>read in child succeeded</code>“ and “<code>read in parent succeeded</code>“.</p>
<h1 id="The-keyboard-interface"><a href="#The-keyboard-interface" class="headerlink" title="The keyboard interface"></a>The keyboard interface</h1><p>为了让 shell 正常工作，我们需要一种方法来输入它。QEMU 已经显示了我们写入 CGA 显示器和串行端口的输出，但是到目前为止，我们只在内核监视器中获取输入。在 QEMU 中，在图形窗口中键入的输入显示为从键盘到 JOS 的输入，而输入到控制台的输入在串行端口上显示为字符。kern/console.c 已经包含了从 lab 1 开始就被内核监视器使用的键盘和串行驱动程序，但是现在您需要将它们附加到系统的其余部分。</p>
<h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9."></a>Exercise 9.</h4><p>在 kern/trap.c 中，调用 kbd_intr 来处理 trap IRQ_OFFSET+IRQ_KBD 和 serial_intr 来处理 trap IRQ_OFFSET+IRQ_SERIAL。</p>
<p>我们在 lib/console.c 中为您实现了控制台输入/输出文件类型。kbd_intr 和 serial_intr 用最近读取的输入填充缓冲区，而控制台文件类型会耗尽缓冲区（控制台文件类型默认用于 stdin/stdout，除非用户重定向它们）</p>
<p>通过运行 make run-testkbd 并键入几行代码来测试代码。当你写完台词时，系统应该把你的台词回音给你。尝试在控制台和图形窗口中键入（如果两者都可用）。</p>
<h1 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h1><p>Run make run-icode or make run-icode-nox. 这将运行内核并启动 user/icode。icode execs init 将控制台设置为文件描述符 0 和 1（标准输入和标准输出）。然后它会产生sh，即 shell。您应该能够运行以下命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">echo hello world | cat</span><br><span class="line">cat lorem |cat</span><br><span class="line">cat lorem |num</span><br><span class="line">cat lorem |num |num |num |num |num</span><br><span class="line">lsfd</span><br></pre></td></tr></table></figure>

<p>注意，用户库例程 cprintf 直接打印到控制台，而不使用文件描述符代码。这对于调试来说很好，但对于管道连接到其他程序中则不太好。要将输出打印到特定的文件描述符（for example，1，standard output），请使用 fprintf（1，“…”，…）。printf（“…”，…）是打印到 fd1的快捷方式。有关示例，请参见 user/lsfd.c。</p>
<h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10."></a>Exercise 10.</h4><p>shell 不支持 I/O 重定向。最好运行 sh  script，而不是像上面那样手工输入脚本中的所有命令。将 &lt; 的 I/O 重定向添加到 user/sh.c。</p>
<p>通过在 shell 中输入 sh &lt;script 来测试实现。</p>
<p>Run make run-testshell to test your shell. <code>testshell</code> simply feeds the above commands (also found in <code>fs/testshell.sh</code>) into the shell and then checks that the output matches <code>fs/testshell.key</code>.</p>
<h4 id="Challenge-5"><a href="#Challenge-5" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>Add more features to the shell. Possibilities include (a few require changes to the file system too):</p>
<ul>
<li>backgrounding commands (<code>ls &amp;</code>)</li>
<li>multiple commands per line (<code>ls; echo hi</code>)</li>
<li>command grouping (<code>(ls; echo hi) | cat &gt; out</code>)</li>
<li>environment variable expansion (<code>echo $hello</code>)</li>
<li>quoting (<code>echo &quot;a | b&quot;</code>)</li>
<li>command-line history and/or editing</li>
<li>tab completion</li>
<li>directories, cd, and a PATH for command-lookup.</li>
<li>file creation</li>
<li>ctl-c to kill the running environment</li>
</ul>
<p>but feel free to do something not on this list.</p>
]]></content>
  </entry>
  <entry>
    <title>Lab 3：用户环境</title>
    <url>/2020/12/02/lab3/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在此 lab 中，您将实现运行受保护的用户模式环境（即”进程”）所需的基本内核功能。您将增强 JOS 内核以设置数据结构来跟踪用户环境、创建单个用户环境、将程序映像加载到其中，并启动运行。您还将使 JOS 内核能够处理用户环境进行的任何系统调用并处理它导致的任何其他异常。</p>
<p><strong>Note：</strong>在此实验中，术语 <em>environment</em> 和 <em>process</em> 是可互换的 - 两者都指允许您运行程序的抽象。我们引入术语 “<em>environment</em>“ 而不是传统术语 “<em>process</em>“，以强调 JOS 环境和 UNIX 进程提供不同接口，并且不提供相同的语义。</p>
<a id="more"></a>

<h2 id="Part-A-User-Environments-and-Exception-Handling"><a href="#Part-A-User-Environments-and-Exception-Handling" class="headerlink" title="Part A: User Environments and Exception Handling"></a>Part A: User Environments and Exception Handling</h2><p>新的文件 <code>inc/env.h</code>包含 JOS 中用户环境的基本定义。现在就读一读。内核使用 Env 数据结构来跟踪每个用户环境。在此 lab 中，您最初将只创建一个环境，但您需要设计 JOS 内核以支持多个环境; lab 4 将利用此功能，允许用户环境 fork 其他环境。</p>
<p>正如您在 <code>kern/env.c</code> 中所看到的，内核维护着与环境相关的三个主要全局变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span> =</span> <span class="literal">NULL</span>;            <span class="comment">// All environments</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">curenv</span> =</span> <span class="literal">NULL</span>;		    <span class="comment">// The current env</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span>	<span class="comment">// Free environment list</span></span><br></pre></td></tr></table></figure>

<p>一旦 JOS 启动并运行，envs 指针指向表示系统内所有环境的 Env 结构数组。在我们的设计中，JOS 内核将支持最多 NENV 个同时处于活动状态的环境，尽管在任何给定时间通常运行环境要少得多。(NENV 是定义在 inc/env.h 中的一个常量。)分配后，envs 数组将包含每个 NENV 可能环境的 Env 数据结构的单个实例。</p>
<p>JOS 内核在 env_free_list 保留所有非活动 Env 结构。此设计允许轻松地分配和回收环境，因为它们只需被添加到空闲列表或从中删除。</p>
<p>内核使用 curenv 符号跟踪当前在任何给定时间正在执行的环境。在启动期间，在运行第一个环境之前，curenv 初始化设置为 NULL。</p>
<h3 id="1-1-Environment-State"><a href="#1-1-Environment-State" class="headerlink" title="1.1 Environment State"></a>1.1 Environment State</h3><p>inc/env.h 中定义如下的 Env 结构（在将来的 lab 中 会添加更多字段）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>	<span class="comment">// Saved registers</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>		<span class="comment">// Next free Env</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_id;				<span class="comment">// Unique environment </span></span><br><span class="line">    							<span class="comment">// identifier</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_parent_id;		<span class="comment">// env_id of this env&#x27;s </span></span><br><span class="line">    							<span class="comment">// parent</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> <span class="title">env_type</span>;</span>		<span class="comment">// Indicates special </span></span><br><span class="line">    							<span class="comment">// system environments</span></span><br><span class="line">	<span class="keyword">unsigned</span> env_status;		<span class="comment">// Status of the </span></span><br><span class="line">    							<span class="comment">// environment</span></span><br><span class="line">	<span class="keyword">uint32_t</span> env_runs;			<span class="comment">// Number of times 		</span></span><br><span class="line">    				<span class="comment">//environment has run Address space</span></span><br><span class="line">	<span class="keyword">pde_t</span> *env_pgdir;		<span class="comment">// Kernel virtual address of </span></span><br><span class="line">    						<span class="comment">// page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是 Env 字段的用处：</p>
<p><strong>env_tf</strong>: 这个结构定义在 inc/trap.h 中，用于保存环境未运行时保存的寄存器值： 当内核或其他环境正在运行时。当从用户模式切换到内核模式时，内核会保存这些内容，以便稍后可以在停止的地方恢复环境。</p>
<p><strong>env_link</strong>: 这是到 env_free_list 上 的下一个 Env 的链接。env_free_list 指向列表中的第一个空闲环境。</p>
<p><strong>env_id</strong>: 内核在这里存储一个值，该值唯一标识当前使用这个 Env 结构的环境。在用户环境终止后，内核可能会将相同的 Env 结构重新分配给不同的环境——但是新环境将拥有与旧环境不同的 env_id，即使新环境重用了 envs 数组中的相同槽。</p>
<p><strong>env_parent_id</strong>: 内核在这里存储创建该环境的环境的 env_id。通过这种方式，环境可以形成一个“家族树”，这将有助于做出有关允许哪些环境对谁执行什么操作的安全决策。</p>
<p><strong>env_type</strong>: 这是用来区分特殊环境的。对于大多数环境，它将是  ENV_TYPE_USER。在以后的 lab 中，我们将为特殊的系统服务环境引进更多的类型。</p>
<p><strong>env_status</strong>: 该变量包含以下值之一:</p>
<ul>
<li><code>ENV_FREE</code>: Env 结构处于非活动状态，因此在 env_free_list 上。</li>
<li><code>ENV_RUNNABLE</code>: Env 结构表示有一个环境正在等待在处理器上运行。</li>
<li><code>ENV_RUNNING</code>: Env 结构表示正在运行的环境。</li>
<li><code>ENV_NOT_RUNNABLE</code>: Env 结构表示当前活动的环境，但它目前尚未准备好运行: 例如，它正在等待来自另一个环境的进程间通信(IPC)。</li>
<li><code>ENV_DYING</code>: Env 结构表示僵尸环境。僵尸环境将在下一次捕获到内核时被释放。在 lab 4 之前我们不会使用这个 flag。</li>
</ul>
<p><strong>env_pgdir</strong>: 这个变量保存这个环境的页目录的内核虚拟地址。</p>
<p>与 Unix 进程一样，JOS 环境也结合了“线程”和“地址空间”的概念。线程主要由保存的寄存器(env_tf 字段)定义，地址空间由 env_pgdir 指向的页目录和页表定义。要运行一个环境，内核必须使用保存的寄存器和适当的地址空间设置 CPU。</p>
<p>我们的 struct Env 类似于 xv6 中的 struct proc。这两个结构都将环境的用户模式寄存器状态保存在 Trapframe 结构中。在 JOS 中，各个环境不像 xv6中 的进程那样拥有自己的内核堆栈。一次内核中只能有一个活动的 JOS 环境，因此 JOS 只需要一个内核堆栈。</p>
<h3 id="1-2-Allocating-the-Environments-Array"><a href="#1-2-Allocating-the-Environments-Array" class="headerlink" title="1.2 Allocating the Environments Array"></a>1.2 Allocating the Environments Array</h3><p>在 lab 2 中，您在 mem_init() 中为 pages[] 数组分配了内存，内核使用这个表来跟踪哪些页面是空闲的，哪些是空闲的。现在需要进一步修改 mem_init()，以分配一个类似的名为 envs 的 Env 结构数组。</p>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1."></a>Exercise 1.</h4><blockquote>
<p>修改 kern/pmap.c 中的 mem_init() 来分配和映射 envs 数组。这个数组完全由分配的 Env 结构的 NENV 实例组成，就像分配页面数组一样。同样像页面数组一样，内存后备 env 也应该映射为 UENVS 的用户只读(在 inc/memlayout.h 中定义)，这样用户进程就可以从这个数组中读取。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">mem_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Make &#x27;envs&#x27; point to an array of size &#x27;NENV&#x27; of </span></span><br><span class="line">    <span class="comment">//&#x27;struct Env&#x27;.</span></span><br><span class="line">    envs = (struct Env*) boot_alloc(<span class="keyword">sizeof</span>(struct Env)* </span><br><span class="line">                                    NENV);</span><br><span class="line">	<span class="built_in">memset</span>(envs, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Env)* NENV);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Map the &#x27;envs&#x27; array read-only by the user at </span></span><br><span class="line">    <span class="comment">// linear address UENVS (ie. perm = PTE_U | PTE_P).</span></span><br><span class="line">	<span class="comment">// Permissions:</span></span><br><span class="line">	<span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></span><br><span class="line">	<span class="comment">//    - envs itself -- kernel RW, user NONE</span></span><br><span class="line">    boot_map_region(kern_pgdir, UENVS, PTSIZE, </span><br><span class="line">                    PADDR(envs), PTE_U);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-Creating-and-Running-Environments"><a href="#1-3-Creating-and-Running-Environments" class="headerlink" title="1.3 Creating and Running Environments"></a>1.3 Creating and Running Environments</h3><p>现在您将在 kern/env.c 中编写运行用户环境所需的代码。因为我们还没有文件系统，所以我们将设置内核来加载嵌入在内核本身中的静态二进制映像。JOS 将此二进制文件作为 ELF 可执行映像嵌入到内核中。Lab 3 GNUmakefile 在 obj/user/ 目录中生成许多二进制映像。如果你看一下 kern/Makefrag，你会注意到一些神奇的地方，把这些二进制文件直接 “链接” 到内核可执行文件中，就好像它们是 .o 文件一样。链接器命令行上的 -b 二进制选项会使这些文件链接为未解释的 “原始” 二进制文件，而不是编译器生成的常规 .o 文件。（就链接器而言，这些文件不必是 ELF 映像——它们可以是任何东西，比如文本文件或图片!）在编译内核之后，如果你观察 obj/kern/kernel.sym，您将注意到链接器 “神奇地” 生成了许多有趣的符号，它们的名称很模糊，比如 _binary_obj_user_hello_start、_binary_obj_user_hello_end和 _binary_obj_user_hello_size。链接器通过修改二进制文件的文件名来生成这些符号名; 这些符号为常规内核代码提供了引用嵌入的二进制文件的方法。</p>
<p>在 kern/init.c 中的 i386_init() 中，您将看到在环境中运行这些二进制映像的代码。然而，建立用户环境的关键功能还不完整; 你需要把它们补充完整。</p>
<h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2."></a>Exercise 2.</h4><blockquote>
<p>完成 env.c 文件中以下函数的编码：</p>
<ul>
<li>env_init()： 初始化 envs 数组中的所有 Env 结构，并将它们添加到env_free_list 中。调用 env_init_percpu，它将分区硬件配置为权限级别为 0 (kernal)和权限级别为 3 (user)的单独段。</li>
<li>env_setup_vm():  为新环境分配一个页目录，并初始化新环境的地址空间的内核部分。</li>
<li>region_alloc() ：为环境分配和映射物理内存。</li>
<li>load_icode()： 您将需要解析 ELF 二进制映像，就像引导加载程序已经做的那样，并将其内容加载到新环境的用户地址空间中。</li>
<li>env_create()：使用 env_alloc 分配环境，并调用 load_icode 将 ELF 二进制文件加载到其中。</li>
<li>env_run()： 启动一个以用户模式运行的给定环境。</li>
</ul>
</blockquote>
<p>在编写这些函数时，可能会发现新的 cprintf 谓词 %e 很有用——它输出与错误代码对应的描述。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r = -E_NO_MEM;</span><br><span class="line">	panic(<span class="string">&quot;env_alloc: %e&quot;</span>, r);</span><br></pre></td></tr></table></figure>

<p>会出现 “<code>env_alloc: out of memory</code>” 的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">//cprintf(&quot;NENV = %d\n&quot;, NENV);</span></span><br><span class="line">	<span class="keyword">for</span>(i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">		envs[i].env_link = env_free_list;</span><br><span class="line">		env_free_list = &amp;envs[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cprintf(&quot;env_init is succeed!\n&quot;);</span></span><br><span class="line">	<span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">	env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">env_setup_vm(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">    e-&gt;env_pgdir = (<span class="keyword">pte_t</span>*)page2kva(p);</span><br><span class="line">	p-&gt;pp_ref++;</span><br><span class="line">	<span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *UP = ROUNDUP(va + len, PGSIZE);</span><br><span class="line">	<span class="keyword">void</span> *DOWN= ROUNDDOWN(va, PGSIZE);</span><br><span class="line">	<span class="keyword">for</span> (; DOWN &lt; UP; DOWN += PGSIZE) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span>;</span></span><br><span class="line">		pp = page_alloc(ALLOC_ZERO);</span><br><span class="line">		<span class="keyword">if</span> (pp) &#123;</span><br><span class="line">			page_insert(e-&gt;env_pgdir, pp, DOWN, PTE_W | </span><br><span class="line">                        PTE_U);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			panic(<span class="string">&quot;regin_alloc env falied!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">load_icode(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 提示：</span></span><br><span class="line">    <span class="comment">// 将每个程序段加载到 ELF 段头中指定地址的虚拟内存中。</span></span><br><span class="line">    <span class="comment">// 您应该只加载 ph-&gt;p_type == ELF_PROG_load 的段。</span></span><br><span class="line">    <span class="comment">// 每个段的虚拟地址可以在 ph-&gt;p_va 中找到，它在内存中的大小可</span></span><br><span class="line">    <span class="comment">// 以在 ph-&gt;p_memsz 中找到。</span></span><br><span class="line">    <span class="comment">// ELF 二进制文件中的 ph-&gt;p_filesz 字节，从 “binary + ph-</span></span><br><span class="line">    <span class="comment">// &gt; p_offset” 开始，应该复制到虚拟地址 ph-&gt;p_va。</span></span><br><span class="line">    <span class="comment">// 任何剩余的内存字节都应清除为零。</span></span><br><span class="line">    <span class="comment">// （ ELF 头应该有 ph-&gt;p_filesz &lt;= ph-&gt;p_memsz。）</span></span><br><span class="line">    <span class="comment">// 使用上一个 lab 的函数来分配和映射页面。</span></span><br><span class="line">	<span class="comment">//    </span></span><br><span class="line">    <span class="comment">// 现在所有页面保护位都应该是用户读/写的。</span></span><br><span class="line">    <span class="comment">// ELF 段不一定是页对齐的，但是对于这个函数，可以假定没有两个</span></span><br><span class="line">    <span class="comment">// 段会接触到同一个虚拟页。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 您可能会发现像 region_alloc 这样的函数很有用。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果可以直接将数据移动到 ELF 二进制文件中存储的虚拟地址中，</span></span><br><span class="line">    <span class="comment">// 那么加载段就简单多了。</span></span><br><span class="line">    <span class="comment">// 那么在这个函数中哪个页目录应该是有效的呢？</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 您还必须对程序的入口点执行一些操作，以确保环境从那里开始执</span></span><br><span class="line">    <span class="comment">// 行。What?  (See env_run() and env_pop_tf() below.)</span></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf_env</span>;</span></span><br><span class="line"></span><br><span class="line">	elf_env = (struct Elf *)binary;</span><br><span class="line">	ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *)(elf_env) + </span><br><span class="line">                             elf_env-&gt;e_phoff);</span><br><span class="line">	eph = ph + elf_env-&gt;e_phnum;</span><br><span class="line"></span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">	<span class="comment">// cprintf(&quot;here arrived!\n&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(; ph &lt; eph; ph++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD)&#123;</span><br><span class="line">			region_alloc(e, (<span class="keyword">void</span> *)ph-&gt;p_va, </span><br><span class="line">                         ph-&gt;p_memsz);</span><br><span class="line">			<span class="built_in">memcpy</span>((<span class="keyword">void</span> *)ph-&gt;p_va, (<span class="keyword">void</span> *)(binary +</span><br><span class="line">                          ph-&gt;p_offset), ph-&gt;p_filesz);</span><br><span class="line">			<span class="comment">// cprintf(&quot;3here arrived!\n&quot;);</span></span><br><span class="line">			<span class="built_in">memset</span>((<span class="keyword">void</span> *)(ph-&gt;p_va + ph-&gt;p_filesz), <span class="number">0</span>,</span><br><span class="line">                   ph-&gt;p_memsz - ph-&gt;p_filesz);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    e-&gt;env_tf.tf_eip = elf_env-&gt;e_entry;</span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line">    <span class="comment">// 现在在虚拟地址 USTACKTOP - PGSIZE 为程序的初始堆栈映射一</span></span><br><span class="line">    <span class="comment">// 个页面。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    region_alloc(e, (<span class="keyword">void</span> *)(USTACKTOP - PGSIZE),</span><br><span class="line">                 PGSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">	env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">	e-&gt;env_type = type;</span><br><span class="line">	<span class="comment">// cprintf(&quot;here arrived!\n&quot;);</span></span><br><span class="line">	load_icode(e, binary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_run(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;</span><br><span class="line">		curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	&#125;</span><br><span class="line">	curenv = e;</span><br><span class="line">	curenv-&gt;env_status = ENV_RUNNING;</span><br><span class="line">	curenv-&gt;env_runs++;</span><br><span class="line">	lcr3(PADDR(curenv-&gt;env_pgdir));</span><br><span class="line">	env_pop_tf(&amp;curenv-&gt;env_tf);</span><br><span class="line">    <span class="comment">// panic(&quot;env_run not yet implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面是调用用户代码之前的代码调用图。确保你理解每一步的目的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">start (kern/entry.S)</span><br><span class="line">i386_init (kern/init.c)</span><br><span class="line">	cons_init</span><br><span class="line">	mem_init</span><br><span class="line">	env_init</span><br><span class="line">	trap_init (still incomplete at <span class="keyword">this</span> point)</span><br><span class="line">	env_create</span><br><span class="line">	env_run</span><br><span class="line">		env_pop_tf</span><br></pre></td></tr></table></figure>

<p>完成之后，应该编译内核并在 QEMU 下运行它。如果一切顺利，系统应该进入用户空间并执行 hello 二进制文件，直到它使用 int 指令进行系统调用为止。这时就会出现问题，因为 JOS 没有设置硬件以允许从用户空间到内核的任何类型的转换。当 CPU 发现它没有设置系统调用的中断处理，它将生成一个通用的保护异常。如果这也无法处理，它将会生成一个双重异常。最终也无法处理时，将所谓的“三重错误”。通常，您会看到 CPU 重置和系统重新启动。尽管这对于遗留应用程序很重要，但对于内核开发来说却很麻烦，因此使用 6.828 补丁 QEMU，您将看到一个寄存器转储和一个“三重错误”消息。</p>
<p>我们将很快解决这个问题，但是现在我们可以使用调试器来检查我们是否进入了用户模式。使用 <code>qemu-gdb</code> 并且在 env_pop_tf 处设置断点，它应该是您实际进入用户模式之前运行的最后一个函数。使用 si 单步通过此函数；使用 iret 指令后处理器应该进入用户模式。然后，您应该看到用户环境的可执行文件中的第一条指令，它是 lib/entry.S 中 start 标签处的 cmpl 指令。现在用 b *0x… 在 sys_cputs() 中在 int $0x30 处设置断点(请参阅 obj/user/hello.asm 中的用户空间地址)。int 是将字符显示到控制台的系统调用。如果你不能执行 int，那么你的地址空间设置或程序加载代码有问题; 在继续之前请返回并修复它。</p>
<h3 id="1-4-Handling-Interrupts-and-Exceptions"><a href="#1-4-Handling-Interrupts-and-Exceptions" class="headerlink" title="1.4 Handling Interrupts and Exceptions"></a>1.4 Handling Interrupts and Exceptions</h3><p>此时，用户空间中的第一个 int $0x30 系统调用指令是死胡同: 一旦处理器进入用户模式，就没有办法返回。现在需要实现基本的异常和系统调用处理，以便内核能够从用户模式代码中恢复对处理器的控制。首先应该彻底熟悉x86中断和异常机制。</p>
<h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3."></a>Exercise 3.</h4><blockquote>
<p>阅读 <a href="../../readings/i386/toc.html">80386 Programmer’s Manual</a> 的 <a href="../../readings/i386/c09.html">Chapter 9, Exceptions and Interrupts</a> 。</p>
</blockquote>
<p>在这个 lab 中，我们通常遵循英特尔关于中断、异常等的术语。但是，像异常、陷阱、中断、故障和中止这样的术语在体系结构或操作系统之间没有标准的含义，它们在 x86 这样的特定体系结构上经常被使用，而不考虑它们之间的细微差别。当你在 lab 之外看到这些词时，它们的意思可能会略有不同。</p>
<h3 id="1-5-Basics-of-Protected-Control-Transfer"><a href="#1-5-Basics-of-Protected-Control-Transfer" class="headerlink" title="1.5 Basics of Protected Control Transfer"></a>1.5 Basics of Protected Control Transfer</h3><p>异常和中断都是”受保护的控制传输”，导致处理器从用户切换到内核模式 （CPL = 0），而不会给用户模式代码任何干扰内核或其他环境功能的机会。在英特尔的术语中，中断是受保护的控制传输，由通常位于处理器外部的异步事件（如外部设备 I/O 活动的通知）引起。相反，一个异常是由当前运行的代码同步导致的受保护控制传输，例如除以零或无效的内存访问。</p>
<p>为了确保这些受保护的控制传输实际受到保护，设计了处理器的中断/异常机制，以便当前在中断或异常发生时运行的代码不会任意选择输入内核的位置或方式。相反，处理器可确保内核只能在精心控制的条件下输入。在 x86 上，两个机制协同工作以提供此保护：</p>
<ol>
<li><p>The Interrupt Descriptor Table.</p>
<p>处理器确保中断和异常只能导致内核在内核本身确定的几个特定、定义良好的入口点输入，而不是由在中断或异常时运行的代码输入。</p>
<p>x86 允许内核中多达 256 个不同的中断或异常入口点，每个点具有不同的中断向量。向量是介于 0 和 255 之间的数字。中断的向量由中断源确定：不同的设备、错误条件和对内核的应用程序请求使用不同的向量生成中断。CPU 使用向量作为处理器中断描述符表 （IDT） 的索引，内核在内核专用内存中设置该表，与 GDT 很像。从此表中的合适条目中，处理器加载：</p>
<ul>
<li>要加载到指令指针 （EIP） 寄存器中的值，指向用于处理该类型的异常的内核代码。</li>
<li>要加载到代码段 （CS） 寄存器中的值，其中包括在位 0-1 中运行异常处理程序的权限级别。（在 JOS 中，所有异常都在内核模式下处理，权限级别 0。）</li>
</ul>
</li>
<li><p>The Task State Segment</p>
<p>处理器需要一个位置来保存中断或异常之前的旧处理器状态，例如在处理器调用异常处理程序之前 EIP 和 CS 的原始值，以便异常处理程序以后可以还原该旧状态，并从那里中断的位置恢复中断的代码。但是，必须保护旧处理器状态的此保存区域免受非特权用户模式代码的保护; 否则错误或恶意用户代码可能会危及内核。</p>
<p>因此，当 x86 处理器发生中断或陷阱导致权限级别从用户模式更改为内核模式时，它也切换到内核内存中的堆栈。称为任务状态段 （TSS） 的结构指定段选择器和此栈所在的地址。处理器推送（在此新堆栈上）SS、ESP、EFLAGS、CS、EIP 和可选错误代码。然后，从中断描述符加载 CS 和 EIP，并设置 ESP 和 SS 来引用新堆栈。</p>
<p>尽管 TSS 很大，可能服务于多种用途，但 JOS 仅使用它来定义处理器在从用户模式切换到内核模式时应切换到的内核堆栈。由于 JOS 中的”内核模式”在 x86 上是特权级别 0，因此处理器在进入内核模式时使用 TSS 的 ESP0 和 SS0 字段来定义内核堆栈。JOS 不使用任何其他 TSS 字段。</p>
</li>
</ol>
<h3 id="1-6-Types-of-Exceptions-and-Interrupts"><a href="#1-6-Types-of-Exceptions-and-Interrupts" class="headerlink" title="1.6 Types of Exceptions and Interrupts"></a>1.6 Types of Exceptions and Interrupts</h3><p>x86 处理器能够产生的所有同步异常使用 0 到 31 之间的中断向量，映射到 IDT 条目 0-31。例如，页面错误始终通过向量 14 产生异常。大于 31 的中断向量仅由软件中断使用，当外部设备需要注意时，软件中断可由 int 指令或异步硬件中断生成。大于 31 的中断向量仅由软件中断使用，软件中断可由 int 指令或当外部设备需要被关注时，由异步硬件中断生成。</p>
<p>在本节中，我们将扩展 JOS 以处理由向量 0-31 内部生成的 x86 异常。下一节我们将使 JOS 处理软件中断向量48（0x30），JOS（相当任意）使用它作为其系统调用中断向量。在 Lab4 中，我们将扩展 JOS 以处理外部生成的硬件中断，如时钟中断。</p>
<h3 id="1-7-An-Example"><a href="#1-7-An-Example" class="headerlink" title="1.7 An Example"></a>1.7 An Example</h3><p>让我们把这些碎片放在一起，并跟踪一个例子。假设处理器在用户环境中执行代码，并遇到尝试除以零的除法指令。</p>
<ol>
<li><p>处理器切换到由 TSS 的 SS0 和 ESP0 字段定义的堆栈，这些字段在 JOS 中将分别保存 GD_KD 和 KSTACKTOP 的值。</p>
</li>
<li><p>处理器在内核堆栈上推送异常参数，从地址 KSTACKTOP 开始：</p>
<p><img src="C:\Users\dier\Pictures\QQ截图20200723191354.png"></p>
</li>
<li><p>由于我们处理的除法错误（在 x86 上是中断向量 0），因此处理器读取 IDT 条目 0 并设置 CS：EIP 以指向条目描述的处理程序函数。</p>
</li>
<li><p>处理程序函数控制并处理异常，例如通过终止用户环境。</p>
</li>
</ol>
<p>对于某些类型的 x86 异常，除了上面的”标准”五个单词外，处理器还推送到堆栈上另一个包含错误代码的单词。页错误异常（数字 14）是一个重要示例。请参阅 80386 手册，确定处理器推送错误代码的异常编号，以及错误代码在这种情况下的含义。当处理器推送错误代码，从用户模式进入异常处理程序时，堆栈将如下所示：</p>
<p><img src="C:\Users\dier\Pictures\QQ截图20200723193408.png"></p>
<h3 id="1-8-Nested-Exceptions-and-Interrupts"><a href="#1-8-Nested-Exceptions-and-Interrupts" class="headerlink" title="1.8 Nested Exceptions and Interrupts"></a>1.8 Nested Exceptions and Interrupts</h3><p>处理器可以从内核和用户模式采取异常和中断。但是，只有在从用户模式进入内核时，x86 处理器才自动切换堆栈，然后再将其旧的寄存器状态推送到堆栈，并通过 IDT 调用相应的异常处理程序。如果处理器在发生中断或异常时已处于内核模式（CS 寄存器的低 2 位已为零），则 CPU 只是在同一内核堆栈上推送更多值。这样，内核就可以优雅地处理由内核本身中的代码引起的嵌套异常。此功能是实现保护的重要工具，我们将在稍后的系统调用部分中看到。</p>
<p>如果处理器已处于内核模式并采用嵌套异常，因为它不需要切换堆栈，因此它不会保存旧的 SS 或 ESP 寄存器。对于不推送错误代码的异常类型，内核堆栈因此在进入异常处理程序时如下所示：</p>
<p><img src="C:\Users\dier\Pictures\QQ截图20200723193910.png"></p>
<p>对于推送错误代码的异常类型，处理器会像以前一样，在旧 EIP 之后立即推送错误代码。</p>
<p>处理器的嵌套异常功能有一个重要的警告。如果处理器在已处于内核模式时发生异常，并且由于缺少堆栈空间等任何原因无法将其旧状态推送到内核堆栈上，则处理器无法恢复，因此它只需重置自身即可。不用说，内核应当精心设计，以便这不会发生。</p>
<h3 id="1-9-Setting-Up-the-IDT"><a href="#1-9-Setting-Up-the-IDT" class="headerlink" title="1.9 Setting Up the IDT"></a>1.9 Setting Up the IDT</h3><p>现在，您应该拥有设置 IDT 和处理 JOS 中的异常所需的基本信息。现在，您将设置 IDT 来处理中断向量 0-31（处理器异常）。我们将在本 lab 的稍后部分处理系统调用中断，并在以后的 lab 中添加中断 32-47（设备 IRQ）。</p>
<p>头文件 inc/trap.h 和 kern/trap.h 包含与中断和异常相关的重要定义，您需要熟悉这些定义。文件 kern/trap.h 包含严格私有于内核的定义，而 inc/trap.h 包含对用户级程序和库也有用的定义。</p>
<p>注意：范围 0-31 中的某些例外情况由 Intel 定义为保留。由于它们永远不会由处理器生成，因此您如何处理它们并不重要。做任何你认为最干净的。</p>
<p>您应该实现的总体控制流程如下所述：</p>
<p><img src="C:\Users\dier\Pictures\QQ截图20200723194530.png"></p>
<p>每个异常或中断都应在 trapentry.S 和 trap_init ()  中拥有自己的处理程序，应使用这些处理程序的地址初始化 IDT。每个处理程序都应在堆栈上构建结构 Trapframe（参见 inc/trap.h），并通过指向 Trapframe.trap() 的指针来调用 trap()（在 trap.c 中），从而处理 异常/中断 或调度到特定的处理程序函数。</p>
<h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4."></a>Exercise 4.</h4><p>编辑 trapentry.S 和 trap.c 并实现上述功能。trapentry.S 中的 TRAPHANDLER 和 TRAPHANDLER_NOEC 的宏应该可以帮助您，以及在 inc/trap.h 中 T_*  的定义。您需要为 inc/trap.h 中定义的每个陷阱在  trapentry.S 中添加一个入口点（使用这些宏），并且您必须提供 TRAPHANDLER 宏引用的 _alltraps。您还需要修改 trap_init()  来初始化 idt，以指向 trapentry.S 中定义的每个入口点; STEGATE 宏将在这里提供帮助。</p>
<p>_alltraps:</p>
<ol>
<li>推送值，使堆栈看起来像一个 Trapframe 结构</li>
<li>加载 GD_KD 到 %ds 和 %es</li>
<li><code>pushl %esp</code> 将指针传送给 Trapframe 作为 trap() 的参数</li>
<li><code>call trap</code>(trap 能返回吗？)</li>
</ol>
<p>考虑使用 pushal 指令；它非常适合 Trapframe 结构的布局。</p>
<p>在进行任何系统调用之前，使用用户目录中导致异常的一些测试程序测试陷阱处理代码，比如 user/divzero。<code>make grade</code> 测试 divzero ，softint，badsegment 是否成功。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab 3: Your code here for generating entry points for the different traps.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TRAPHANDLER_NOEC(V_DIVIDE, T_DIVIDE);</span><br><span class="line">TRAPHANDLER_NOEC(V_DEBUG, T_DEBUG);</span><br><span class="line">TRAPHANDLER_NOEC(V_NMI, T_NMI);</span><br><span class="line">TRAPHANDLER_NOEC(V_BRKPT, T_BRKPT);</span><br><span class="line">TRAPHANDLER_NOEC(V_OFLOW, T_OFLOW);</span><br><span class="line">TRAPHANDLER_NOEC(V_BOUND, T_BOUND);</span><br><span class="line">TRAPHANDLER_NOEC(V_ILLOP, T_ILLOP);</span><br><span class="line">TRAPHANDLER(V_DEVICE, T_DEVICE);</span><br><span class="line">TRAPHANDLER_NOEC(V_DBLFLT, T_DBLFLT);</span><br><span class="line">TRAPHANDLER(V_TSS, T_TSS);</span><br><span class="line">TRAPHANDLER(V_SEGNP, T_SEGNP);</span><br><span class="line">TRAPHANDLER(V_GPFLT, T_GPFLT);</span><br><span class="line">TRAPHANDLER(V_PGFLT, T_PGFLT);</span><br><span class="line">TRAPHANDLER(V_STACK, T_STACK);</span><br><span class="line">TRAPHANDLER_NOEC(V_FPERR, T_FPERR);</span><br><span class="line"></span><br><span class="line">TRAPHANDLER(V_ALIGN, T_ALIGN);</span><br><span class="line">TRAPHANDLER_NOEC(V_MCHK, T_MCHK);</span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(V_SIMDERR, T_SIMDERR);</span><br><span class="line">TRAPHANDLER_NOEC(V_SYSCALL, T_SYSCALL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab 3: Your code here for _alltraps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_alltraps:</span><br><span class="line">	pushl %ds</span><br><span class="line">	pushl %es</span><br><span class="line">	pushal</span><br><span class="line">	mov $GD_KD, %ax</span><br><span class="line">	mov %ax, %ds</span><br><span class="line">	mov %ax, %es</span><br><span class="line">	pushl %esp</span><br><span class="line">	call trap	</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_DIVIDE</span><span class="params">()</span></span>; <span class="comment">//</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_DEBUG</span><span class="params">()</span></span>;  <span class="comment">//</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_NMI</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_BRKPT</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_OFLOW</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_BOUND</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_ILLOP</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_DEVICE</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_DBLFLT</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// void V_COPROC();</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_TSS</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_SEGNP</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_STACK</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_GPFLT</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_PGFLT</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// void V_RES();</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_FPERR</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_ALIGN</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_MCHK</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_SIMDERR</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// void V_IRQOFFSET();</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_SYSCALL</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, V_DIVIDE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	SETGATE(idt[T_DEBUG], <span class="number">0</span>, GD_KT, V_DEBUG, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_NMI], <span class="number">0</span>, GD_KT, V_NMI, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	SETGATE(idt[T_BRKPT], <span class="number">0</span>, GD_KT, V_BRKPT, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	SETGATE(idt[T_OFLOW], <span class="number">0</span>, GD_KT, V_OFLOW, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_BOUND], <span class="number">0</span>, GD_KT, V_BOUND, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_ILLOP], <span class="number">0</span>, GD_KT, V_ILLOP, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_DEVICE], <span class="number">0</span>, GD_KT, V_DEVICE, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_DBLFLT], <span class="number">0</span>, GD_KT, V_DBLFLT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SETGATE(idt[T_COPROC], 0, GD_KT, V_COPROC, 0);</span></span><br><span class="line"></span><br><span class="line">	SETGATE(idt[T_TSS], <span class="number">0</span>, GD_KT, V_TSS, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_SEGNP], <span class="number">0</span>, GD_KT, V_SEGNP, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_STACK], <span class="number">0</span>, GD_KT, V_STACK, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_GPFLT], <span class="number">0</span>, GD_KT, V_GPFLT, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_PGFLT], <span class="number">0</span>, GD_KT, V_PGFLT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SETGATE(idt[T_RES], 0, GD_KT, V_RES, 0);</span></span><br><span class="line"></span><br><span class="line">	SETGATE(idt[T_FPERR], <span class="number">0</span>, GD_KT, V_FPERR, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_ALIGN], <span class="number">0</span>, GD_KT, V_ALIGN, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_MCHK], <span class="number">0</span>, GD_KT, V_MCHK, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, V_SIMDERR, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, V_SYSCALL, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><p>您现在可能有很多非常相似的代码，在 trapentry.S 中的 TRAPHANDLER 列表和 trap.c 中的安装之间。清理一下。更改 trapentry.S 中的宏以自动生成用于 trap.c 的表。请注意，您可以使用指令 .text 和 .data 在汇编程序中布局代码和数据之间切换。</p>
<h4 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h4><ol>
<li>为每个异常/中断设置单独的处理程序函数的目的是什么？（即，如果将所有异常/中断传递到同一处理程序，则无法提供当前实现中存在的哪些功能？</li>
<li>您是否必须执行一些操作才能使 user/softint 正常运行？grade 脚本期望它产生通用保护故障（陷阱 13），但 softint’s code says  int $14。为什么这会产生中断向量 13？如果内核实际上允许 softint 的 int $14 指令调用内核的页面错误处理程序（即中断向量 14），会发生什么？</li>
</ol>
<h2 id="Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Part B: Page Faults, Breakpoints Exceptions, and System Calls"></a>Part B: Page Faults, Breakpoints Exceptions, and System Calls</h2><p>您的内核具有基本的异常处理功能，现在您将对其进行优化，以提供依赖于异常处理的重要操作系统原语。</p>
<h3 id="2-1-Handling-Page-Faults"><a href="#2-1-Handling-Page-Faults" class="headerlink" title="2.1 Handling Page Faults"></a>2.1 Handling Page Faults</h3><p>页面故障，中断向量14（T_PGFLT）是一个特别重要的异常，我们将在本 lab 和下一个 lab 中进行大量的练习。当处理器出现页面故障时，它将导致错误的线性（即虚拟）地址存储在一个特殊的处理器控制寄存器 CR2 中。在 trap.c 中，我们提供了一个特殊函数 page_fault_handler() 的开头，用于处理页面错误异常。</p>
<h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5."></a>Exercise 5.</h4><p>修改 trap_dispatch() 以将页错误异常分派给 page_fault_handler()。</p>
<h3 id="2-2-The-Breakpoint-Exception"><a href="#2-2-The-Breakpoint-Exception" class="headerlink" title="2.2 The Breakpoint Exception"></a>2.2 The Breakpoint Exception</h3><p>断点异常，中断向量3（T_BRKPT）通常用于允许调试器通过临时将相关程序指令替换为特殊的 1 字节 int3 软件中断指令，在程序代码中插入断点。在 JOS 中，我们将稍微滥用此异常，将其转换为任何用户环境都可以用来调用JOS内核监视器的原始伪系统调用。如果我们认为 JOS 内核监视器是一个原始调试器，那么这种用法实际上是合适的。例如，lib/panic.c 中 panic() 的用户模式实现在显示其 panic 消息后执行 int3。</p>
<h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6."></a>Exercise 6.</h4><p>修改 trap_dispatch() 使断点异常调用内核监视器。</p>
<h4 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge"></a>Challenge</h4><p>修改 JOS 内核监视器，以便您可以从当前位置“继续”执行（例如，在 int3 之后，如果内核监视器是通过断点异常调用的），并且您可以一次执行一个指令。您需要了解 EFLAGS 寄存器的某些位才能实现单步执行。</p>
<h4 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h4><p>如果你真的很有冒险精神，可以找到一些 x86 反汇编程序的源代码——例如，从 QEMU 或者 GNU binutils 中解压出来，或者直接自己编写——然后扩展 JOS 内核监视器，以便在你单步执行指令时能够反汇编和显示指令。结合 Lab 1 中的符号表加载，这就是真正的内核调试器的组成部分。</p>
<h4 id="Questions-1"><a href="#Questions-1" class="headerlink" title="Questions"></a>Questions</h4><ol start="3">
<li>断点测试用例将生成断点异常或通用保护错误，这取决于您如何初始化 IDT 中的断点条目（即，从 trap_init 调用 SETGATE）。为什么？您需要如何设置它才能使断点异常按照上面指定的方式工作？什么不正确的设置会导致它触发一般保护故障？</li>
<li>你认为这些机制的意义是什么，特别是考虑到 user/softint 测试程序的作用？</li>
</ol>
<h3 id="2-3-System-calls"><a href="#2-3-System-calls" class="headerlink" title="2.3 System calls"></a>2.3 System calls</h3><p>用户进程通过调用系统调用请求内核为它们做一些事情。当用户进程调用系统调用时，处理器进入内核模式，处理器和内核协同保存用户进程的状态，内核执行适当的代码来执行系统调用，然后恢复用户进程。用户进程如何得到内核关注的的额外细节，以及内核如何决定它想要执行的调用，这在不同的系统中各有不同。</p>
<p>在 JOS 内核中，我们将使用 int 指令，它会导致处理器中断。特别是，我们将使用 int $0x30 作为系统调用中断。我们已经为您定义了常数 T_SYSCALL 为48（0x30）。您必须设置中断描述符，以允许用户进程引起该中断。请注意，中断 0x30 不能由硬件生成，因此允许用户代码生成它不会引起歧义。</p>
<p>应用程序将在寄存器中传递系统调用号和系统调用参数。这样，内核就不需要在用户环境的堆栈或指令流中到处搜寻。系统调用号将进入 %eax，参数（最多五个）将分别进入 %edx、%ecx、%ebx、%edi 和 %esi。内核将返回值传回 %eax。调用系统调用的汇编代码已经在 lib/syscall.c 中的 syscall() 中为您编写。您应该通读它并确保您理解发生了什么。</p>
<h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7."></a>Exercise 7.</h4><p>在内核中为中断向量 T_SYSCALL 添加一个处理程序。您必须编辑 kern/trapentry.S 和 kern/trap.c 的 trap_init()。您还需要更改 trap_dispatch() 来处理系统调用中断，方法是使用适当的参数调用 syscall()（在 kern/syscall.c 中定义），然后安排将返回值传回 %eax 中的用户进程。最后，需要在 kern/syscall.c 中实现 syscall()。如果系统调用号无效，请确保 syscall() 返回 -E_INVAL。您应该阅读并理解lib/syscall.c（尤其是内联程序集例程），以确认您对系统调用接口的理解。通过为每个调用调用调用相应的内核函数来处理 inc/syscall.h 中列出的所有系统调用。</p>
<p>在内核下运行 user/hello 程序（make run-hello）。它应该在控制台上打印 “hello，world”，然后在用户模式下导致页面错误。如果没有发生这种情况，可能意味着系统调用处理程序不太正确。你现在也应该能够获得 make grade，以便在 testbss 测试中获得成功。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Handle processor exceptions.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_trapno == T_PGFLT) &#123;</span><br><span class="line">		<span class="keyword">return</span> page_fault_handler(tf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_trapno == T_BRKPT) &#123;</span><br><span class="line">		<span class="keyword">return</span> monitor(tf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle syscall</span></span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_trapno == T_SYSCALL) &#123;</span><br><span class="line">		tf-&gt;tf_regs.reg_eax = syscall(</span><br><span class="line">						tf-&gt;tf_regs.reg_eax,</span><br><span class="line">						tf-&gt;tf_regs.reg_edx,</span><br><span class="line">						tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">						tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">						tf-&gt;tf_regs.reg_edi,</span><br><span class="line">						tf-&gt;tf_regs.reg_esi</span><br><span class="line">						);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span></span><br><span class="line">	<span class="comment">// Return any appropriate return value.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// panic(&quot;syscall not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">		<span class="keyword">case</span> SYS_cputs:</span><br><span class="line">			sys_cputs((<span class="keyword">char</span> *)a1, a2);</span><br><span class="line">		<span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">			<span class="keyword">return</span> sys_cgetc();</span><br><span class="line">		<span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">			<span class="keyword">return</span> sys_getenvid();</span><br><span class="line">		<span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">			<span class="keyword">return</span> sys_env_destroy(sys_getenvid());		</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge"></a>Challenge</h4><p>使用 sysenter 和 sysexit 指令而不是使用 int 0x30 和 iret 来实现系统调用。</p>
<p>sysenter/sysexit 指令由 Intel 设计,比 int/iret 更快。它们通过使用寄存器而不是堆栈来实现这一点，并假设分段寄存器是如何被使用的。有关这些指令的详细信息，请参阅英特尔参考手册 2B 卷。</p>
<p>在 JOS 中添加对这些指令的支持的最简单的方法是在 kern/trapentry.S 中添加一个sysenter_handler 处理程序，该处理程序保存足够的用户环境信息，以便返回，设置内核环境，将参数推送到 syscall() 并直接调用 syscall()。一旦 syscall() 返回，为设置所有内容并执行 sysexit 指令。您还需要向 kern/init.c 添加代码，以设置必要的特定于模型的寄存器（MSRs）。《AMD 体系结构程序员手册》第 2 卷第 6.1.2 节和《英特尔参考手册》第 2B 卷中有关 syscenter 的参考资料对相关的 MSR 进行了很好的描述。您可以在这里找到 wrmsr 的一个实现，添加到 inc/x86.h 中以写入这些 MSRs。</p>
<p>最后，lib/syscall.c 必须更改为支持使用 sysenter 进行系统调用。以下是sysenter指令可能的寄存器布局：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">eax                - syscall number</span><br><span class="line">edx, ecx, ebx, edi - arg1, arg2, arg3, arg4</span><br><span class="line">esi                - <span class="keyword">return</span> pc</span><br><span class="line">ebp                - <span class="keyword">return</span> esp</span><br><span class="line">esp                - trashed by sysenter</span><br></pre></td></tr></table></figure>

<p>GCC 的内联汇编程序将自动保存寄存器，告诉它直接将值加载到其中。不要忘记保存（push）和恢复（pop）您要删除的其他寄存器，或者告诉内联汇编程序您正在清除它们。内联汇编程序不支持保存 %ebp，因此您需要添加代码来保存和还原它。返回地址可以通过使用诸如 leal 之类的指令放到 %esi 中，该指令 <code>leal after_sysenter_label, %%esi</code>。</p>
<p>请注意，这只支持 4 个参数，因此您需要保留执行系统调用的旧方法来支持 5 个参数的系统调用。此外，由于这种快速路径不能更新当前环境的陷阱帧，因此它不适合我们在以后的实验中添加的一些系统调用。</p>
<p>一旦我们在下一个 lab 中启用了异步中断，您可能需要重新访问您的代码。具体地说，当返回到用户进程时，需要启用中断，而 sysexit 不能为您做到这一点。</p>
<h3 id="2-4-User-mode-startup"><a href="#2-4-User-mode-startup" class="headerlink" title="2.4 User-mode startup"></a>2.4 User-mode startup</h3><p>用户程序开始在 lib/entry.S 的顶部运行。完成一些设置之后，这段代码调用libmain()，在 lib/libmain.c 中。您应该修改 libmain() 来初始化全局指针 thisenv，以指向 envs[] 数组中该环境的 struct Env。（请注意，lib/entry.S 已经定义了 env，以指向您在 A 部分中设置的 UENVS 映射。）提示：查找 inc/env.h 并使用 sys_getenvid。</p>
<p>libmain() 然后调用 umain，对于 hello 程序，它位于 user/hello.c 中。注意，在打印 “hello，world” 之后，它会尝试访问 thisenv-&gt;env_id。这就是它早些时候出现故障的原因。现在已经正确初始化了 thisenv，它应该不会出错。如果它仍然存在故障，那么您可能还没有映射用户可读的 UENVS 区域。（回到 pmap.c 的 A 部分；这是我们第一次实际使用 UENVS 区域）。</p>
<h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8."></a>Exercise 8.</h4><p>将所需的代码添加到用户库，然后引导内核。您应该看到 user/hello 打印 “hello，world”，然后打印 “i am environment 0000100”。user/hello 然后通过调用sys_env_destroy() 尝试 “exit”（请参见 lib/libmain.c 和 lib/exit.c）。由于内核目前只支持一个用户环境，它应该报告它已经销毁了唯一的环境，然后进入内核监视器。</p>
<h3 id="2-5-Page-faults-and-memory-protection"><a href="#2-5-Page-faults-and-memory-protection" class="headerlink" title="2.5 Page faults and memory protection"></a>2.5 Page faults and memory protection</h3><p>内存保护是操作系统的一项重要功能，确保一个程序中的错误不会损坏其他程序或损坏操作系统本身。</p>
<p>操作系统通常依赖硬件支持来实现内存保护。操作系统让硬件知道哪些虚拟地址有效，哪些无效。当一个程序试图访问一个无效的地址或它没有权限访问的地址时，处理器会在导致错误的指令处停止程序，然后在内核中捕获有关尝试操作的信息。如果错误是可修复的，内核可以修复它并让程序继续运行。如果故障不可修复，则程序将无法继续，因为它永远无法通过导致故障的指令。</p>
<p>作为一个可修复错误的例子，考虑一个自动扩展的堆栈。在许多系统中，内核最初分配一个堆栈页，然后如果程序访问堆栈下一层的页面出错，内核将自动分配这些页面并让程序继续运行。通过这样做，内核只分配程序所需的栈内存，但是程序可以在它有任意大的堆栈的假象下工作。</p>
<p>系统调用为内存保护提出了一个有趣的问题。大多数系统调用接口允许用户程序传递指向内核的指针。这些指针指向要读或写的用户缓冲区。然后内核在执行系统调用时取消引用这些指针。这有两个问题：</p>
<ol>
<li> 内核中的页面错误可能比用户程序中的页面错误严重得多。如果内核页面在操作自己的数据结构时出错，那就是一个内核错误，错误处理程序应该使内核恐慌（从而导致整个系统）。但是当内核取消对用户程序给它的指针的引用时，它需要一种方法来记住这些引用导致的任何页错误实际上都是代表用户程序的。</li>
<li> 内核通常比用户程序拥有更多的内存权限。用户程序可能会传递一个指向系统调用的指针，该系统调用指向内核可以读或写但程序不能读写的内存。内核必须小心不要被诱骗去引用这样一个指针，因为这可能会泄露私有信息或破坏内核的完整性。</li>
</ol>
<p>由于这两个原因，内核在处理用户程序提供的指针时必须非常小心。</p>
<p>现在，您将使用一种机制来解决这两个问题，该机制将仔细检查从用户空间传递到内核的所有指针。当程序向内核传递指针时，内核将检查地址是否在地址空间的用户部分，以及页表是否允许内存操作。</p>
<p>因此，内核永远不会因为取消引用用户提供的指针而出现页面故障。如果内核出现页面故障，它应该死机并终止。</p>
<h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9."></a>Exercise 9.</h4><blockquote>
<p>如果在内核模式下发生页面错误，请将 kern/trap.c 更改为 panic。</p>
</blockquote>
<blockquote>
<p>提示：要确定故障是在用户模式还是在内核模式下发生，请检查 tf_cs 的低位。</p>
</blockquote>
<blockquote>
<p>读取 kern/pmap.c 中的 user_mem_assert，并在同一个文件中实现 user_mem_check。</p>
<p>启动内核，运行user/buggyhello。环境应该被破坏，内核不应该惊慌失措。你应该看到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;[<span class="number">00001000</span>] user_mem_check assertion failure <span class="keyword">for</span> va </span><br><span class="line">									<span class="number">00000001</span></span><br><span class="line">&gt;[<span class="number">00001000</span>] <span class="built_in">free</span> env <span class="number">00001000</span></span><br><span class="line">&gt;Destroyed the only environment - nothing more to <span class="keyword">do</span>!</span><br></pre></td></tr></table></figure>

<p>最后，在 kern/kdebug.c 中更改 debuginfo_eip，以调用 user_mem_check 对 usd、stabs 和 stabstr 的检查。如果现在运行 user/breakpoint，那么应该能够从内核监视器运行回溯，并在内核因页面错误而死机之前看到回溯遍历到 lib/libmain.c。是什么导致了这个页面错误？你不需要修理它，但你应该明白为什么会这样。</p>
</blockquote>
<p>请注意，您刚才实现的相同机制也适用于恶意用户应用程序（例如user/evilhello）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">user_mem_check(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> </span><br><span class="line">										len, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// 检查是否允许环境使用“perm | PTE_P”权限访问内存范围[va，</span></span><br><span class="line">    <span class="comment">//											va+len]。</span></span><br><span class="line">    <span class="comment">// 通常 “perm” 至少包含 PTE_U，但这不是必需的。</span></span><br><span class="line">    <span class="comment">// “va”和“len”不需要页对齐；您必须测试每个包含该范围的页面。</span></span><br><span class="line">    <span class="comment">// 您将测试 “len/PGSIZE”、 “len/PGSIZE+1”或</span></span><br><span class="line">    <span class="comment">//           						“len/PGSIZE+2”页。</span></span><br><span class="line">    <span class="comment">// 一个用户程序可以访问一个虚拟地址，如果（1）地址在ULIM之下，</span></span><br><span class="line">    <span class="comment">//（2）页表赋予它权限。这些正是您应该在这里实现的测试。</span></span><br><span class="line">    <span class="comment">// 如果出现错误，请将“user_mem_check_addr”变量设置为第一个</span></span><br><span class="line">    <span class="comment">// 错误的虚拟地址。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 如果用户程序可以访问此地址范围，则返回0；否则返回</span></span><br><span class="line">    <span class="comment">// -E_FAULT。</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">uint32_t</span> down = (<span class="keyword">uint32_t</span>)ROUNDDOWN((<span class="keyword">uint32_t</span>)va, </span><br><span class="line">                                        PGSIZE);</span><br><span class="line">	<span class="keyword">uint32_t</span> up = (<span class="keyword">uint32_t</span>)ROUNDUP((<span class="keyword">uint32_t</span>)va + len, </span><br><span class="line">                                    PGSIZE);</span><br><span class="line">	<span class="keyword">int</span> perm_c = (perm | PTE_P);</span><br><span class="line">	<span class="keyword">for</span> (; down &lt; up; down = down + PGSIZE ) &#123;</span><br><span class="line">		<span class="comment">// cprintf(&quot;down = %x&quot;, down);</span></span><br><span class="line">		<span class="keyword">pte_t</span> *pte = pgdir_walk(env-&gt;env_pgdir, </span><br><span class="line">                                (<span class="keyword">void</span> *)down, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> ((down &gt;= ULIM) || (!pte) || </span><br><span class="line">            ((*pte &amp; perm_c) != perm_c)) &#123;</span><br><span class="line">			user_mem_check_addr = (down &gt;= (<span class="keyword">uint32_t</span>)va ?</span><br><span class="line">                                   down : (<span class="keyword">uint32_t</span>)va);</span><br><span class="line">			<span class="keyword">return</span> -E_FAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((tf-&gt;tf_cs &amp; <span class="number">011</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">		panic(<span class="string">&quot;page fault in kernel mode!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">debuginfo_eip(<span class="keyword">uintptr_t</span> addr, struct Eipdebuginfo *info)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Make sure this memory is valid.</span></span><br><span class="line">	<span class="comment">// Return -1 if it is not. Hint: Call user_mem_check.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> (user_mem_check(curenv, usd, <span class="keyword">sizeof</span>(struct </span><br><span class="line">                               UserStabData), PTE_U)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// Make sure the STABS and string table memory is </span></span><br><span class="line">    <span class="comment">// valid.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> (user_mem_check(curenv, stabs, stab_end - stabs,</span><br><span class="line">                       PTE_U)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (user_mem_check(curenv, stabstr, stabstr_end -</span><br><span class="line">                       stabstr, PTE_U)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>



<h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10."></a>Exercise 10.</h4><p>启动内核，运行 user/evilhello。环境应该被破坏，内核不应该 panic。你应该看到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">00000000</span>] <span class="keyword">new</span> env <span class="number">00001000</span></span><br><span class="line">	...</span><br><span class="line">[<span class="number">00001000</span>] user_mem_check assertion failure <span class="keyword">for</span> va </span><br><span class="line">											f010000c</span><br><span class="line">[<span class="number">00001000</span>] <span class="built_in">free</span> env <span class="number">00001000</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Lab 6: 网络驱动</title>
    <url>/2020/12/02/lab6/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>本 Lab 是你可以自己进行的最后一个项目。</p>
<p>现在你有了一个文件系统，任何一个有自尊的操作系统都不应该没有网络堆栈。在这个 Lab 中，你要写一个网络接口卡的驱动程序。该卡将基于 Intel 82540EM 芯片，也称为 E1000。</p>
<p>然而，网卡驱动程序不足以让你的操作系统连接到互联网上。在新的 lab 6 代码中，我们为您提供了一个网络堆栈和一个网络服务器。与以前的实验一样，使用 git 获取这个实验的代码，合并到您自己的代码中，并研究新 net/ 目录中的内容，以及 kern/ 中的新文件。</p>
<p>除了编写驱动程序外，您还需要创建一个系统调用接口，以便访问您的驱动程序。通过完成一个 web 服务器，您还可以将所有内容绑定在一起。使用新的 web 服务器，您将能够从文件系统中提供文件。</p>
<a id="more"></a>

<p>大部分内核设备驱动程序代码都必须从头开始编写。这个 Lab 提供的指导比以前的实验少得多：没有骨架文件，没有用石头写的系统调用接口，许多设计决策都由您来决定。因此，我们建议你在开始任何单独的练习之前，先阅读整个作业摘要。许多学生发现这个实验比以前的实验更难，所以请相应地安排你的时间。</p>
<h2 id="QEMU’s-virtual-network"><a href="#QEMU’s-virtual-network" class="headerlink" title="QEMU’s virtual network"></a>QEMU’s virtual network</h2><p>我们将使用 QEMU 的用户模式网络堆栈，因为它不需要管理特权来运行。QEMU 的文档在这里有更多关于用户网的信息。我们更新了 makefile 以启用 QEMU 的用户模式网络堆栈和虚拟 E1000 网卡。</p>
<p>默认情况下，QEMU 提供一个运行在 ip 10.0.2.2 上的虚拟路由器，并将为 JOS 分配 IP 地址 10.0.2.15。为了简单起见，我们将这些默认值硬编码到 net/ns.h 中的网络服务器中。</p>
<p>虽然 QEMU 的虚拟网络允许 JO S任意连接到 Internet，但 JOS 的 10.0.2.15 地址在 QEMU 内部运行的虚拟网络之外没有任何意义（也就是说，QEMU 充当 NAT），因此我们不能直接连接到运行在 JOS 内部的服务器，即使是从运行 QEMU 的主机。为了解决这个问题，我们将 QEMU 配置为在主机上的某个端口上运行一个服务器，该服务器只需连接到 JOS 中的某个端口，并在真实主机和虚拟网络之间来回传输数据。</p>
<p>您将在端口 7（echo）和端口 80（http）上运行 JOS 服务器。为了避免在共享的 Athena 机器上发生冲突，makefile 根据用户 ID 为这些机器生成转发端口。要了解 QEMU 要转发到开发主机上的哪个端口，请运行 make which-ports。为了方便起见，makefile 还提供 make nc-7 和 make nc-80，允许您直接与终端中这些端口上运行的服务器交互。（这些目标只连接到正在运行的 QEMU 实例；必须单独启动 QEMU 本身。）</p>
<h3 id="Packet-Inspection"><a href="#Packet-Inspection" class="headerlink" title="Packet Inspection"></a>Packet Inspection</h3><p>makefile 还配置 QEMU 的网络堆栈，以记录所有传入和传出的数据包 qemu.pcap 文件在你的 Lab 目录里。</p>
<p>要获取捕获数据包的 hex/ASCII 转储，请使用 tcpdump，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tcpdump -XXnr qemu.pcap</span><br></pre></td></tr></table></figure>

<p>或者，可以使用 Wireshark 以图形方式检查 pcap 文件。Wireshark 还知道如何解码和检查数百个网络协议。</p>
<h3 id="Debugging-the-E1000"><a href="#Debugging-the-E1000" class="headerlink" title="Debugging the E1000"></a>Debugging the E1000</h3><p>我们很幸运能够使用仿真硬件。由于 E1000 是在软件中运行的，因此模拟的 E1000 可以以用户可读的格式向我们报告其内部状态和遇到的任何问题。通常情况下，这样的奢华对于一个用裸金属编写的驱动程序开发人员来说是很难获得的。</p>
<p>E1000 可以产生大量调试输出，因此必须启用特定的日志记录通道。您可能会发现一些有用的渠道是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Flag		Meaning</span><br><span class="line">tx			Log packet transmit operations</span><br><span class="line">txerr		Log transmit ring errors</span><br><span class="line">rx			Log changes to RCTL</span><br><span class="line">rxfilter	Log filtering of incoming packets</span><br><span class="line">rxerr		Log receive ring errors</span><br><span class="line">unknown		Log reads <span class="keyword">and</span> writes of unknown registers</span><br><span class="line">eeprom		Log reads from the EEPROM</span><br><span class="line">interrupt	Log interrupts <span class="keyword">and</span> changes to interrupt </span><br><span class="line">											registers.</span><br></pre></td></tr></table></figure>

<p>例如,，要启用 “tx” 和 “txerr” 日志记录，请使用 make E1000_DEBUG=tx，txerr…</p>
<blockquote>
<p>注意：E1000_DEBUG 标志仅在 QEMU 的 6.828 版本中有效。</p>
</blockquote>
<p>您可以进一步使用软件仿真硬件进行调试。如果您曾经被卡住，并且不明白为什么 E1000 没有按照您预期的方式响应，那么可以查看 hw/net/E1000.c 中 QEMU 的 E1000 实现。</p>
<h2 id="The-Network-Server"><a href="#The-Network-Server" class="headerlink" title="The Network Server"></a>The Network Server</h2><p>从头开始编写网络堆栈是一项艰巨的工作。相反，我们将使用 lwIP，一个开源的轻量级 TCP/IP 协议套件，其中包括一个网络堆栈。你可以在这里找到更多关于 lwIP的信息。在这个任务中，就我们而言，lwIP 是一个实现 BSD 套接字接口的黑盒，它有一个分组输入端口和一个分组输出端口。</p>
<p>网络服务器实际上是四种环境的组合：</p>
<ul>
<li>核心网络服务器环境（包括socket call dispatcher和lwIP）</li>
<li>输入环境</li>
<li>输出环境</li>
<li>定时器环境</li>
</ul>
<p>下图显示了不同的环境及其关系。该图显示了包括设备驱动程序在内的整个系统，稍后将介绍。在这个实验中，你将实现用绿色突出显示的部分。</p>
<p><img src="C:\Users\dier\Pictures\ns.png" alt="ns"></p>
<h3 id="The-Core-Network-Server-Environment"><a href="#The-Core-Network-Server-Environment" class="headerlink" title="The Core Network Server Environment"></a>The Core Network Server Environment</h3><p>核心网络服务器环境由 socket 调用调度器和 lwIP 本身组成。socket 调用调度器的工作方式与文件服务器完全相同。用户环境使用 stubs（可以在 lib/nsipc.c 中找到）向核心网络环境发送 IPC 消息。如果你看 lib/nsipc.c，你会发现我们找到核心网络服务器的方式和找到文件服务器的方式是一样的：i386_init 用 NS_TYPE_NS 创建了 NS 环境，所以我们扫描 env，寻找这个特殊的环境类型。对于每个用户环境 IPC，网络服务器中的调度器代表用户调用 lwIP 提供的相应 BSD 套接字接口函数。</p>
<p>常规用户环境不直接使用 nsipc_*  调用。相反，它们使用 lib/sockets.c 中的函数，该函数提供了一个基于文件描述符的 sockets API。因此，用户环境通过文件描述符引用套接字，就像它们在磁盘文件中引用的那样。许多操作（connect、accept等）都是特定于套接字的，但是读、写和关闭都要经过 lib/fd.c 中的普通文件描述符设备调度代码。就像文件服务器为所有打开的文件维护内部唯一 ID 一样，lwIP 也为所有打开的套接字生成唯一 ID。在文件服务器和网络服务器中，我们使用struct Fd 中存储的信息将每个环境的文件描述符映射到这些唯一的 ID 空间。</p>
<p>尽管看起来文件服务器和网络服务器的 IPC 调度器的行为是相同的，但有一个关键的区别。像 accept 和 recv 这样的 BSD 套接字调用可以无限期地阻塞。如果调度程序让 lwIP 执行这些阻塞调用中的一个，那么调度程序也将阻塞，并且整个系统一次只能有一个未完成的网络调用。由于这是不可接受的，网络服务器使用用户级线程来避免阻塞整个服务器环境。对于每个传入的 IPC 消息，调度器创建一个线程并在新创建的线程中处理请求。如果线程阻塞，则只有该线程处于休眠状态，而其他线程继续运行。</p>
<p>除了核心网络环境外，还有三个辅助环境。除了接受来自用户应用程序的消息外，核心网络环境的调度器还接受来自输入和计时器环境的消息。</p>
<h3 id="The-Output-Environment"><a href="#The-Output-Environment" class="headerlink" title="The Output Environment"></a>The Output Environment</h3><p>当为用户环境套接字调用提供服务时，lwIP 将生成数据包供网卡传输。LwIP 将使用 NSREQ_OUTPUT IPC 消息将要传输的每个数据包发送到输出助手环境，并将数据包附加在 IPC 消息的页参数中。输出环境负责接受这些消息，并通过您即将创建的系统调用接口将数据包转发到设备驱动程序。</p>
<h3 id="The-Input-Environment"><a href="#The-Input-Environment" class="headerlink" title="The Input Environment"></a>The Input Environment</h3><p>网卡接收到的数据包需要注入 lwIP。对于设备驱动程序接收到的每个数据包，输入环境将数据包从内核空间中拉出（使用您将实现的内核系统调用），并使用NSREQ_INPUT IPC 消息将数据包发送到核心服务器环境。</p>
<p>数据包输入功能与核心网络环境分离，因为 JOS 使得同时接受 IPC 消息和轮询或等待来自设备驱动程序的数据包变得很困难。我们在 JOS 中没有 select 系统调用，它允许环境监视多个输入源，以确定哪些输入可以被处理。</p>
<p>如果您看一下 net/input.c 和 net/output.c，就会发现这两个都需要实现。这主要是因为实现依赖于您的系统调用接口。在实现驱动程序和系统调用接口之后，您将为两个 helper 环境编写代码。</p>
<h3 id="The-Timer-Environment"><a href="#The-Timer-Environment" class="headerlink" title="The Timer Environment"></a>The Timer Environment</h3><p>计时器环境定期向核心网络服务器发送 NSREQ_TIMER 类型的消息，通知它计时器已过期。来自这个线程的计时器消息被 lwIP 用来实现各种网络超时。</p>
<h1 id="Part-A-Initialization-and-transmitting-packets"><a href="#Part-A-Initialization-and-transmitting-packets" class="headerlink" title="Part A: Initialization and transmitting packets"></a>Part A: Initialization and transmitting packets</h1><p>你的内核没有时间的概念，所以我们需要添加它。目前有一个时钟中断是由硬件每 10 毫秒产生一次。在每一个时钟中断时，我们可以增加一个变量来表示时间提前了 10 毫秒。这是在 kern/time.c 中实现的，但尚未完全集成到内核中。</p>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1."></a>Exercise 1.</h4><p>为 kern/trap.c 中的每个时钟中断添加对 time_tick 的调用。实现 sys_time_msec 并将其添加到 kern/syscall.c 中的 syscall 中，以便用户空间可以访问时间。</p>
<p>使用 make INIT_CFLAGS=-DTEST_NO_NS run-testtime 来测试时间代码。您应该可以看到环境在 1 秒的间隔内从 5 开始倒计时。”-DTEST_NO_NS” ”禁用启动网络服务器环境，因为它将在 Lab 的这个点死机。</p>
<h2 id="1-The-Network-Interface-Card"><a href="#1-The-Network-Interface-Card" class="headerlink" title="1. The Network Interface Card"></a>1. The Network Interface Card</h2><p>编写驱动程序需要深入了解硬件和提供给软件的接口。实验文本将提供有关如何与 E1000 接口的高级概述，但在编写驱动程序时，您需要充分利用 Intel 的手册。</p>
<h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2."></a>Exercise 2.</h4><p>浏览 Intel 的 E1000 软件开发人员手册。本手册涵盖了几个密切相关的以太网控制器。QEMU 模仿 82540EM。</p>
<p>你现在应该浏览一下第二章来了解一下这个设备。要编写驱动程序，您需要熟悉第 3 章和第 14 章，以及 4.1（尽管不是 4.1 小节）。你还需要参考第 13 章。其他章节主要介绍 E1000 的组件，您的驱动器不必与这些组件交互。现在不必担心细节；只需了解一下文档的结构，这样以后就可以找到东西了。</p>
<p>在阅读本手册时，请记住，E1000 是一款具有许多高级功能的精密设备。一个正常工作的 E1000 驱动程序只需要 NIC 提供的功能和接口的一小部分。仔细考虑与卡连接的最简单方法。我们强烈建议您在使用高级功能之前先让一个基本的驱动程序工作。</p>
<h3 id="1-1-PCI-Interface"><a href="#1-1-PCI-Interface" class="headerlink" title="1.1 PCI Interface"></a>1.1 PCI Interface</h3><p>E1000 是 PCI 设备，这意味着它可以插入主板上的 PCI 总线。PCI 总线有地址、数据和中断线，允许 CPU 与 PCI 设备通信，PCI 设备读写内存。PCI 设备在使用之前需要被发现和初始化。发现是在 PCI 总线上寻找连接设备的过程。初始化是分配 I/O 和内存空间以及协商 IRQ 线以供设备使用的过程。</p>
<p>我们在 kern/pci.c 中为您提供了 PCI 代码。为了在引导期间执行 PCI 初始化，PCI 代码遍历 PCI 总线寻找设备。当它找到一个设备时，它会读取它的供应商 ID 和设备 ID，并使用这两个值作为一个键来搜索 pci 连接的供应商数组。该数组由 struct pci_driver 项组成，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> key1, key2;</span><br><span class="line">    <span class="keyword">int</span> (*attachfn) (struct pci_func *pcif);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果发现的设备的供应商 ID 和设备 ID 与阵列中的某个条目匹配，PCI 代码将调用该条目的 attachfn 来执行设备初始化。（设备也可以通过类来标识，这是 kern/pci.c 中另一个驱动程序表的用途。）</p>
<p>向 attach 函数传递一个 PCI 函数进行初始化。PCI 卡可以公开多个功能，但 E1000 只公开一个功能。下面是我们如何在 JOS 中表示 PCI 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_func</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_bus</span> *<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> dev;</span><br><span class="line">    <span class="keyword">uint32_t</span> func;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> dev_id;</span><br><span class="line">    <span class="keyword">uint32_t</span> dev_class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> reg_base[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_size[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> irq_line;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述结构反映了开发人员手册第 4.1 节表 4-1 中的一些条目。struct pci_func 的最后三个条目对我们特别感兴趣，因为它们记录了设备的协商内存、I/O 和中断源。寄存器基址和寄存器大小数组包含多达六个基址寄存器或 BARs 的信息。reg_base 存储内存映射 I/O 区域（或 I/O 端口资源的基本 I/O 端口）的基本内存地址，reg_size 包含来自 reg_base 的相应基本值的大小（以字节为单位）或 I/O 端口数，irq_line 包含分配给设备的中断 IRQ 行。表 4-2 后半部分给出了 E1000 条的具体含义。</p>
<p>调用设备的附加功能时，设备已找到但尚未启用。这意味着 PCI 代码还没有确定分配给设备的资源，例如地址空间和 IRQ 行，因此，struct pci_func 结构的最后三个元素尚未填充。attach 函数应该调用 pci_chfunc_enable，它将启用设备、协商这些资源并填充结构 pci_func。</p>
<h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3."></a>Exercise 3.</h4><p>实现 attach 函数以初始化 E1000。在 kern/pci.c 中向 pci_attach_vendor 数组添加一个条目，以便在找到匹配的 pc i设备时触发您的函数（确保将它放在标记表末尾的 {0，0，0} 项之前）。您可以在第 5.2 节中找到 QEMU 模拟的 82540EM 的供应商 ID 和设备 ID。当 JOS 在引导时扫描 PCI 总线时，您还应该看到这些列表。</p>
<p>现在，只需通过 pci_func_enable 启用 E1000 设备。我们将在整个实验室中添加更多的初始化。</p>
<p>我们已经为您提供了 kern/e1000.c 和 kern/e1000.h 文件，这样您就不需要破坏构建系统了。它们当前为空；您需要在本练习中填写它们。您可能还需要在内核的其他位置包含 e1000.h 文件。</p>
<p>当您启动内核时，您应该看到它显示 E1000 卡的 PCI 功能已启用。您的代码现在应该通过 make grade 的 pci 连接测试。</p>
<h3 id="1-2-Memory-mapped-I-O"><a href="#1-2-Memory-mapped-I-O" class="headerlink" title="1.2 Memory-mapped I/O"></a>1.2 Memory-mapped I/O</h3><p>软件通过内存映射 I/O（MMIO）与 E1000 通信。在 JOS 中你已经见过两次了：CGA 控制台和 LAPIC 都是通过对“内存”进行读写来控制和查询的设备。但是这些读写操作不会进入 DRAM；它们直接进入这些设备。</p>
<p>pci_func_enable 与 E1000协商 MMIO 区域，并将其基数和大小存储在 BAR 0 中（也就是说，reg_base[0] 和 reg_size[0]）。这是分配给设备的物理内存地址范围，这意味着您必须通过虚拟地址来访问它。由于 MMIO 区域被分配了非常高的物理地址（通常超过 3GB），所以由于 JOS 的 256MB 限制，您不能使用 KADDR 来访问它。因此，您必须创建一个新的内存映射。我们将使用 MMIOBASE 上面的区域（您的来自 Lab 4 的 mmio_map_region 将确保我们不会覆盖 LAPIC 使用的映射）。由于 PCI 设备初始化发生在 JOS 创建用户环境之前，所以您可以在 kern_pgdir 中创建映射，并且该映射始终可用。</p>
<h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4."></a>Exercise 4.</h4><p>在 attach 函数中，通过调用 mmio_map_region（您在 Lab 4 中编写的支持 LAPIC内存映射）为 E1000 的 BAR 0 创建一个虚拟内存映射。</p>
<p>您需要将这个映射的位置记录在一个变量中，以便以后可以访问刚刚映射的寄存器。查看 kern/lapic.c 中的 lapic 变量，以了解一种方法。如果你确实使用了指向设备寄存器映射的指针，一定要声明它是 volatile；否则，允许编译器缓存值并重新排序对该内存的访问。</p>
<p>要测试映射，请尝试打印设备状态寄存器（第 13.4.2 节）。这是一个 4 字节寄存器，从寄存器空间的字节 8 开始。您应该得到 0x80080783，这表示全双工链路的速度是 1000MB/s。</p>
<p>提示：你需要很多常量，比如寄存器的位置和位掩码的值。试图从开发人员手册中复制这些内容是很容易出错的，错误可能会导致痛苦的调试会话。我们建议使用 QEMU 的 e1000_hw.h 头作为指导。我们不建议一字不差地复制它，因为它定义的内容远远超出了您实际需要的范围，并且可能无法按照您需要的方式定义内容，但这是一个很好的起点。</p>
<h3 id="1-3-DMA"><a href="#1-3-DMA" class="headerlink" title="1.3 DMA"></a>1.3 DMA</h3><p>您可以想象通过写入和读取 E1000 的寄存器来发送和接收数据包，但这会很慢，并且需要 E1000 在内部缓冲包数据。您可以想象通过写入和读取 E1000 的寄存器来发送和接收数据包，但这会很慢，并且需要 E1000 在内部缓冲包数据。驱动程序负责为发送和接收队列分配内存，设置 DMA 描述符，并为 E1000 配置这些队列的位置，但之后的一切都是异步的。为了发送分组，驱动程序将其复制到发送队列中的下一个 DMA 描述符中，并通知 E1000 另一个分组可用；当有时间发送数据包时，E1000 将从描述符中复制数据。同样，当 E1000 接收到一个数据包时，它将其复制到接收队列中的下一个 DMA 描述符中，驱动程序可以在下一个机会从中读取。</p>
<p>接收队列和传输队列在高层非常相似。两者都由一系列描述词组成。虽然这些描述符的确切结构各不相同，但每个描述符都包含一些标志和包含数据包数据的缓冲区的物理地址（卡要发送的数据包数据，或操作系统为卡分配的缓冲区，以将接收到的数据包写入其中）。</p>
<p>队列被实现为圆形数组，这意味着当卡或驱动程序到达数组的末尾时，它会返回到数组的开头。它们都有一个头指针和一个尾指针，队列的内容是这两个指针之间的描述符。硬件总是从头部使用描述符并移动头部指针，而驱动程序总是向尾部添加描述符并移动尾部指针。传输队列中的描述符表示等待发送的包（因此，在稳定状态下，传输队列为空）。对于接收队列，队列中的描述符是卡可以接收数据包的空闲描述符（因此，在稳定状态下，接收队列由所有可用的接收描述符组成）。在不混淆 E1000 的情况下正确更新尾寄存器是很困难的；小心！</p>
<p>指向这些数组的指针以及描述符中数据包缓冲区的地址都必须是物理地址，因为硬件直接执行 DMA 往返于物理 RAM 而不经过 MMU。</p>
<h2 id="2-Transmitting-Packets"><a href="#2-Transmitting-Packets" class="headerlink" title="2. Transmitting Packets"></a>2. Transmitting Packets</h2><p>E1000 的发送和接收功能基本上是相互独立的，因此我们可以一次处理一个。我们将首先攻击发送数据包，因为如果不发送 “I’m here!” 就无法测试接收先打包。</p>
<p>首先，您必须按照 14.5 节中描述的步骤初始化卡以进行传输（您不必担心子部分）。传输初始化的第一步是设置传输队列。队列的精确结构在第 3.4 节中描述，描述符的结构在第 3.3.3 节中描述。我们不会使用 E1000 的 TCP 卸载功能，所以您可以关注 “legacy transmit descriptor format”。你现在应该阅读这些章节并熟悉这些结构。</p>
<h3 id="2-1-C-Structures"><a href="#2-1-C-Structures" class="headerlink" title="2.1 C Structures"></a>2.1 C Structures</h3><p>您将发现使用 C 结构来描述 E1000 的结构非常方便。正如您在 struct Trapframe 等结构中看到的，C 结构允许您精确地在内存中布局数据。C 可以在字段之间插入填充，但是 E1000 的结构是这样布置的，这样就不会有问题了。如果确实遇到字段对齐问题，请查看 GCC 的 “packed” 属性。</p>
<p>以本手册表 3-8 中给出的旧传输描述符为例，并在此复制：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">63</span>            <span class="number">48</span> <span class="number">47</span>   <span class="number">40</span> <span class="number">39</span>   <span class="number">32</span> <span class="number">31</span>   <span class="number">24</span> <span class="number">23</span>   <span class="number">16</span> <span class="number">15</span>     <span class="number">0</span></span><br><span class="line">  +-----------------------------------------------------+</span><br><span class="line">  |                         Buffer address                   |</span><br><span class="line">  +---------------+-------+-------+-------+-------+-----+</span><br><span class="line">  |    Special   |  CSS  | Status|  Cmd  | CSO | Length  |</span><br><span class="line">  +---------------+-------+-------+-------+-------+-----+</span><br></pre></td></tr></table></figure>

<p>结构的第一个字节从右上角开始，因此要将其转换为 C 结构，请从右到左、从上到下读取。如果您正确地斜视它，您将看到所有字段甚至可以很好地适应标准大小的类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint64_t</span> addr;</span><br><span class="line">	<span class="keyword">uint16_t</span> length;</span><br><span class="line">	<span class="keyword">uint8_t</span> cso;</span><br><span class="line">	<span class="keyword">uint8_t</span> cmd;</span><br><span class="line">	<span class="keyword">uint8_t</span> status;</span><br><span class="line">	<span class="keyword">uint8_t</span> css;</span><br><span class="line">	<span class="keyword">uint16_t</span> special;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>驱动程序必须为传输描述符数组和传输描述符指向的数据包缓冲区预留内存。有几种方法可以做到这一点，从动态分配页面到简单地在全局变量中声明页面。无论您选择什么，请记住 E1000 直接访问物理内存，这意味着它访问的任何缓冲区在物理内存中都必须是连续的。</p>
<p>还有多种方法可以处理数据包缓冲区。我们建议从最简单的开始，就是在驱动程序初始化期间为每个描述符预留一个包缓冲区的空间，并简单地将包数据复制到这些预先分配的缓冲区中。以太网数据包的最大大小是 1518 字节，这限制了这些缓冲区的大小。更复杂的驱动程序可以动态地分配数据包缓冲区（例如，在网络使用率较低时减少内存开销），甚至可以传递用户空间直接提供的缓冲区（一种称为“零拷贝”的技术），但最好从简单开始。</p>
<h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5."></a>Exercise 5.</h4><p>执行第 14.5 节（但不包括其小节）中描述的初始化步骤。使用第 13 节作为初始化过程引用的寄存器的参考，使用第 3.3.3 节和第 3.4 节作为传输描述符和传输描述符数组的参考。</p>
<p>请注意传输描述符阵列的对齐要求和此阵列长度的限制。由于 TDLEN 必须是 128 字节对齐的，并且每个传输描述符是 16 字节，因此传输描述符数组将需要 8 个传输描述符中的若干个。但是，不要使用超过 64 个描述符，否则我们的测试将无法测试传输环溢出。</p>
<p>对于 TCTL.COLD，可以采用全双工操作。对于 TIPG，参考 IEEE 802.3 标准 IPG 第 13.4.34 节表 13-77 中所述的默认值（不要使用 14.5 节表中的值）。</p>
<p>尝试运行 mak E1000_DEBUG=TXERR，TX qemu。如果您正在使用课程 qemu，当您设置 TDT 寄存器时，应该会看到一条 “e1000:tx disabled” 消息（因为这发生在设置之前 TCEN.CN)没有更多的 “e1000” 信息。</p>
<p>既然传输已经初始化，您就必须编写代码来传输数据包，并通过系统调用使其可以访问用户空间。要传输数据包，必须将其添加到传输队列的尾部，这意味着将数据包数据复制到下一个数据包缓冲区，然后更新 TDT（传输描述符尾部）寄存器，以通知卡在传输队列中还有另一个包。（请注意，TDT 是传输描述符数组的索引，而不是字节偏移量；文档对此不是很清楚。）</p>
<p>然而，传输队列只有这么大。如果卡落后于传输数据包，并且传输队列已满，会发生什么情况？为了检测到这种情况，您需要 E1000 提供一些反馈。不幸的是，不能只使用 TDH（传输描述符头）寄存器；文档明确指出从软件中读取此寄存器是不可靠的。但是，如果您在传输描述符的命令字段中设置 RS 位，那么当卡在该描述符中传输了包时，该卡将在描述符的状态字段中设置 DD 位。如果设置了描述符的 DD 位，您就知道回收该描述符并使用它来传输另一个数据包是安全的。</p>
<p>如果用户调用您的传输系统调用，但下一个描述符的 DD 位没有设置，这表示传输队列已满，该怎么办？你得决定在这种情况下该怎么办。你可以把包裹扔了。网络协议对此是有弹性的，但是如果丢弃大量的数据包，协议可能无法恢复。相反，您可以告诉用户环境，它必须重试，就像您对 sys_ipc_try_send 所做的那样。这样做的好处是将生成数据的环境向后推。</p>
<h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6."></a>Exercise 6.</h4><p>编写一个函数，通过检查下一个描述符是否空闲，将数据包数据复制到下一个描述符中，并更新 TDT 来传输数据包。确保处理的传输队列已满。</p>
<p>现在是测试包传输代码的好时机。通过直接从内核调用传输函数，尝试只传输一些数据包。您不必创建符合任何特定网络协议的数据包来进行测试。运行 make E1000_DEBUG=TXERR，TX qemu 来运行测试。当你传输数据包时。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e1000: index <span class="number">0</span>: <span class="number">0x271f00</span> : <span class="number">9000002</span>a <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>每行给出传输数组中的索引、该传输描述符的缓冲区地址、cmd/CSO/length 字段和 special/CSS/status 字段。如果 QEMU 没有从传输描述符中打印出您期望的值，请检查您填写的描述符是否正确，以及 TDBAL 和 TDBAH 的配置是否正确。如果您收到 “e1000:TDH wrapparound@0，TDT x，TDLEN y” 消息，这意味着 e1000在传输队列中一路运行而没有停止（如果 QEMU 没有检查这个，它将进入一个无限循环），这可能意味着您没有正确地操作 TDT。</p>
<p>一旦 QEMU 运行，就可以运行 tcpdump-XXnr qemu.pcap 文件以查看您传输的数据包。如果您看到来自 QEMU 的预期 “e1000:index” 消息，但您的数据包捕获是空的，请仔细检查您是否在传输描述符中填写了所有必需的字段和位（e1000 可能遍历了您的传输描述符，但认为它不必发送任何内容）。</p>
<h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7."></a>Exercise 7.</h4><p>添加一个允许从用户空间传输数据包的系统调用。具体界面由您决定。不要忘记检查从用户空间传递到内核的任何指针。</p>
<h2 id="3-Transmitting-Packets-Network-Server"><a href="#3-Transmitting-Packets-Network-Server" class="headerlink" title="3. Transmitting Packets: Network Server"></a>3. Transmitting Packets: Network Server</h2><p>现在你有了一个系统调用接口到你的设备驱动程序的传输端，是时候发送数据包了。输出辅助环境的目标是在循环中执行以下操作：接受来自核心网络服务器的NSREQ_OUTPUT IPC 消息，并使用上面添加的系统调用将这些 IPC 消息附带的数据包发送到网络设备驱动程序。NSREQ_OUTPUT IPC 由 net/lwip/jos/jif/jif.c 中的low_level_output 函数发送，该函数将 lwip 堆栈粘到 jos 的网络系统上。每个 IPC将包括一个由 union Nsipc 组成的页面，其中的数据包位于其 struct jif_pkt pkt 字段中（参见 inc/ns.h）。struct jif_pkt 结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jif_pkt</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> jp_len;</span><br><span class="line">    <span class="keyword">char</span> jp_data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>jp_len 表示数据包的长度。IPC 页上的所有后续字节都专用于数据包内容。在结构末尾使用零长度数组（如 jp_data）是一种常见的 C 技巧（有人会说讨厌），用于表示没有预先确定长度的缓冲区。由于 C 不做数组边界检查，只要确保结构后面有足够的未使用内存，就可以像使用任何大小的数组一样使用 jp_data。</p>
<p>当设备驱动程序的传输队列中没有更多空间时，请注意设备驱动程序、输出环境和核心网络服务器之间的交互。核心网络服务器使用 IPC 向输出环境发送数据包。如果由于驱动程序没有更多的缓冲区空间用于新的数据包而由于发送数据包系统调用而暂停输出环境，则核心网络服务器将阻塞等待输出服务器接受 IPC 调用。</p>
<h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8."></a>Exercise 8.</h4><p>实现 <code>net/output.c</code>.</p>
<p>您可以使用 net/testoutput.c 测试输出代码，而不需要涉及整个网络服务器。尝试运行 make E1000_DEBUG=tTXERR，TX run-net_testoutput。你应该看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transmitting packet 0</span><br><span class="line">e1000: index 0: 0x271f00 : 9000009 0</span><br><span class="line">Transmitting packet 1</span><br><span class="line">e1000: index 1: 0x2724ee : 9000009 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>and  tcpdump -XXnr qemu.pcap  should output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reading from file qemu.pcap, link-type EN10MB (Ethernet)</span><br><span class="line">-5:00:00.600186 [|ether]</span><br><span class="line">	0x0000:  5061 636b 6574 2030 30            Packet.00</span><br><span class="line">-5:00:00.610080 [|ether]</span><br><span class="line">	0x0000:  5061 636b 6574 2030 31            Packet.01</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>要使用更大的数据包计数进行测试，try make E1000_DEBUG=TXERR,TX NET_CFLAGS=-DTESTOUTPUT_COUNT=100 run-net_testoutput。如果这溢出了传输环，请再次检查您是否正确地处理了 DD 状态位，并且您已经告诉硬件设置了 DD 状态位（使用 RS 命令位）。</p>
<p>您的代码应该通过 make-grade 的 testoutput 测试。</p>
<h4 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h4><p>您是如何构建传输实现的？特别是，如果传输环满了怎么办？</p>
<h1 id="Part-B-Receiving-packets-and-the-web-server"><a href="#Part-B-Receiving-packets-and-the-web-server" class="headerlink" title="Part B: Receiving packets and the web server"></a>Part B: Receiving packets and the web server</h1><h2 id="1-Receiving-Packets"><a href="#1-Receiving-Packets" class="headerlink" title="1. Receiving Packets"></a>1. Receiving Packets</h2><p>就像传输数据包一样，您必须配置 E1000 来接收数据包，并提供接收描述符队列和接收描述符。</p>
<h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9."></a>Exercise 9.</h4><p>阅读第3.2节。您可以忽略关于中断和校验和卸载的任何内容（如果您稍后决定使用这些功能，您可以返回到这些部分），并且您不必关心阈值的细节以及卡的内部缓存是如何工作的。</p>
<p>接收队列与传输队列非常相似，只是它由等待填充入站数据包的空数据包缓冲区组成。因此，当网络空闲时，传输队列是空的（因为所有的包都已发送），但是接收队列是满的（空包缓冲区）。</p>
<p>当 E1000 接收到一个数据包时，它首先检查它是否与卡上配置的过滤器匹配（例如，查看该数据包是否指向该 E1000 的 MAC 地址），如果该数据包与任何过滤器都不匹配，则忽略该数据包。否则，E1000 将尝试从接收队列的头部检索下一个接收描述符。如果 head（RDH）赶上了 tail（RDT），那么接收队列就没有空闲描述符了，因此卡会丢弃数据包。如果有空闲的接收描述符，它将数据包数据复制到描述符指向的缓冲区，设置描述符的 DD（描述符完成）和 EOP（数据包结束）状态位，并增加 RDH。</p>
<p>如果 E1000 在一个接收描述符中接收到大于包缓冲区的包，则它将从接收队列中检索所需数量的描述符，以存储包的全部内容。为了表明发生了这种情况，它将在所有这些描述符上设置 DD status 位，但只在最后一个描述符上设置 EOP status 位。您可以在驱动程序中处理这种可能性，也可以简单地将卡配置为不接受“长数据包”（也称为巨型帧），并确保接收缓冲区足够大以存储最大的标准以太网数据包（1518 字节）。</p>
<h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10."></a>Exercise 10.</h4><p>按照 14.4 节中的过程设置接收队列并配置 E1000。你不必支持“长数据包”或多播。现在，不要将卡配置为使用中断；如果您决定使用接收中断，您可以稍后更改它。另外，配置 E1000 以剥离以太网 CRC，因为 grade 脚本期望它被剥离。</p>
<p>默认情况下，该卡将过滤掉所有数据包。您必须用卡自己的 MAC 地址配置接收地址寄存器（RAL 和 RAH），以便接收发往该卡的数据包。你可以简单地硬编码 QEMU 的默认 MAC 地址 52:54:00:12:34:56（我们已经在 lwIP 中硬编码了，所以在这里做也不会让事情变得更糟）。注意字节顺序；MAC 地址是从最低顺序字节写入最高顺序字节的，因此 52:54:00:12 是 MAC 地址的低位 32 位，34:56 是高位 16 位。</p>
<p>E1000 仅支持一组特定的接收缓冲区大小（在 RCTL.B 大小第 13.4.22 节）。如果使接收包缓冲区足够大并禁用长数据包，就不必担心数据包跨越多个接收缓冲区。另外，请记住，与传输一样，接收队列和数据包缓冲区在物理内存中必须是连续的。</p>
<p>您应该使用至少 128 个接收描述符。</p>
<p>现在您可以对接收功能进行基本测试，即使不编写接收数据包的代码。运行 make E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER run-net_testinput。testinput 将传输一个 ARP（地址解析协议）公告包（使用包传输系统调用），QEMU 将自动回复该包。即使您的驱动程序还无法收到此回复，您也应该看到 “e1000:unicast match[0]：52:54:00:12:34:56” 消息，表明 e1000 已接收到一个数据包，并且与配置的接收筛选器匹配。如果您看到 “e1000:unicast mismatch:52:54:00:12:34:56” 消息，e1000 会过滤掉数据包，这意味着您可能没有正确配置 RAL 和 RAH。确保字节排序正确，并且不要忘记在 RAH 中设置 “Address Valid” 位。如果没有收到任何 “e1000” 消息，则可能没有正确启用 receive。</p>
<p>现在可以实现接收包了。要接收数据包，您的驱动程序必须跟踪它希望保存下一个接收到的数据包的描述符（提示：根据您的设计，E1000 中可能已经有一个寄存器在跟踪这个数据包）。与传输类似，文档声明 RDH 寄存器不能从软件中可靠地读取，因此为了确定数据包是否已被传递到描述符的数据包缓冲区，您必须读取描述符中的 DD 状态位。如果设置了 DD 位，您可以将数据包数据从描述符的数据包缓冲区中复制出来，然后通过更新队列的尾部索引 RDT 告诉卡描述符是空闲的。</p>
<p>如果未设置 DD 位，则没有收到任何数据包。这相当于传输队列已满时的接收端，在这种情况下您可以做一些事情。您只需返回一个“重试”错误并要求调用方重试。虽然这种方法对于完全传输队列很有效，因为这是一个暂时的条件，但是对于空的接收队列则不太合理，因为接收队列可能会在很长一段时间内保持为空。第二种方法是挂起调用环境，直到接收队列中有要处理的数据包为止。这种策略与 sys_ipc_recv 非常相似。就像 IPC 的情况一样，由于每个 CPU 只有一个内核堆栈，所以一旦离开内核，堆栈上的状态就会丢失。我们需要设置一个标志，指示环境已被接收队列下溢挂起，并记录系统调用参数。这种方法的缺点是复杂性：必须指示 E1000 生成接收中断，并且驱动程序必须处理这些中断，以便恢复阻塞的等待数据包的环境。</p>
<h4 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11."></a>Exercise 11.</h4><p>编写一个函数从 E1000 接收数据包，并通过添加系统调用将其公开给用户空间。</p>
<h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><p>如果传输队列已满或接收队列为空，则环境和驱动程序可能会花费大量的 CPU 周期进行轮询，等待描述符。E1000 在使用传输或接收描述符完成后可以生成中断，从而避免了轮询的需要。修改您的驱动程序，使处理发送和接收队列都是中断驱动的，而不是轮询。</p>
<p>请注意，一旦中断被断言，它将保持断言状态，直到驱动程序清除该中断为止。在中断处理程序中，确保在处理中断后立即清除它。如果不这样做，在从中断处理程序返回后，CPU 将再次跳回中断处理程序。除了清除 E1000 卡上的中断之外，还需要在 LAPIC 上清除中断。使用 lapic_eoi 进行此操作。</p>
<h2 id="2-Receiving-Packets-Network-Server"><a href="#2-Receiving-Packets-Network-Server" class="headerlink" title="2. Receiving Packets: Network Server"></a>2. Receiving Packets: Network Server</h2><p>在网络服务器输入环境中，您需要使用新的接收系统调用来接收数据包，并使用NSREQ_INPUT IPC 消息将它们传递到核心网络服务器环境。这些 IPC 输入消息应该有一个带有 union Nsipc 的页面，其 struct jif_pkt pkt 字段用从网络接收的包填充。</p>
<h4 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12."></a>Exercise 12.</h4><p>实现 <code>net/input.c</code>.</p>
<p>运行 <code>make E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER run-net_testinput</code>，会出现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Sending ARP announcement...</span><br><span class="line">Waiting <span class="keyword">for</span> packets...</span><br><span class="line">e1000: index <span class="number">0</span>: <span class="number">0x26dea0</span> : <span class="number">900002</span>a <span class="number">0</span></span><br><span class="line">e1000: unicast match[<span class="number">0</span>]: <span class="number">52</span>:<span class="number">54</span>:<span class="number">00</span>:<span class="number">12</span>:<span class="number">34</span>:<span class="number">56</span></span><br><span class="line">input: <span class="number">0000</span>   <span class="number">5254</span> <span class="number">0012</span> <span class="number">3456</span> <span class="number">5255</span>  <span class="number">0</span>a00 <span class="number">0202</span> <span class="number">0806</span> <span class="number">0001</span></span><br><span class="line">input: <span class="number">0010</span>   <span class="number">0800</span> <span class="number">0604</span> <span class="number">0002</span> <span class="number">5255</span>  <span class="number">0</span>a00 <span class="number">0202</span> <span class="number">0</span>a00 <span class="number">0202</span></span><br><span class="line">input: <span class="number">0020</span>   <span class="number">5254</span> <span class="number">0012</span> <span class="number">3456</span> <span class="number">0</span>a00  <span class="number">020f</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">input: <span class="number">0030</span>   <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br></pre></td></tr></table></figure>

<p>以 “input:” 开头的行是 QEMU 的 ARP 回复的十六进制转储。</p>
<p>您的代码应该通过 make-grade 的 testinput 测试。请注意，如果不发送至少一个 ARP 包来通知 QEMU JOS 的 IP 地址，就无法测试数据包的接收，因此传输代码中的错误会导致测试失败。</p>
<p>为了更彻底地测试您的网络代码，我们提供了一个名为 echosrv 的守护程序，它设置了一个运行在端口 7 上的 echo 服务器，该服务器将回送通过 TCP 连接发送的任何内容。使用 make E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER run-echosrv 在一个终端中启动 echo 服务器，并在另一个终端中 make nc-7 连接到它。你输入的每一行都应该被服务器回显。每次仿真的 E1000 接收到数据包时，QEMU 应该在控制台上打印如下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e1000: unicast match[<span class="number">0</span>]: <span class="number">52</span>:<span class="number">54</span>:<span class="number">00</span>:<span class="number">12</span>:<span class="number">34</span>:<span class="number">56</span></span><br><span class="line">e1000: index <span class="number">2</span>: <span class="number">0x26ea7c</span> : <span class="number">9000036</span> <span class="number">0</span></span><br><span class="line">e1000: index <span class="number">3</span>: <span class="number">0x26f06a</span> : <span class="number">9000039</span> <span class="number">0</span></span><br><span class="line">e1000: unicast match[<span class="number">0</span>]: <span class="number">52</span>:<span class="number">54</span>:<span class="number">00</span>:<span class="number">12</span>:<span class="number">34</span>:<span class="number">56</span></span><br></pre></td></tr></table></figure>

<p>此时，可以通过 echosrv 测试。</p>
<h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h4><p>你是如何组织你的接收实现的？特别是，如果接收队列为空，并且用户环境请求下一个传入数据包，您将怎么做？</p>
<h4 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge"></a>Challenge</h4><p>阅读开发人员手册中的 EEPROM，并编写代码将 E1000 的 MAC 地址从 EEPROM 中加载出来。目前，QEMU 的默认 MAC 地址被硬编码到接收初始化和 lwIP 中。修复初始化以使用从 EEPROM 读取的 MAC 地址，添加系统调用以将 MAC 地址传递给 lwIP，并将 lwIP 修改为从卡读取的 MAC 地址。通过配置 QEMU 使用不同的 MAC 地址来测试您的更改。</p>
<h4 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge"></a>Challenge</h4><p>将 E1000 驱动程序修改为“零拷贝”。目前，包数据必须从用户空间缓冲区复制到传输包缓冲区，并从接收包缓冲区复制回用户空间缓冲区。零拷贝驱动程序通过让用户空间和 E1000 直接共享数据包缓冲存储器来避免这种情况。有许多不同的方法可以实现这一点，包括将内核分配的结构映射到用户空间，或者将用户提供的缓冲区直接传递给 E1000。不管您的方法是什么，请注意如何重用缓冲区，以免在用户空间代码和 E1000 之间引入竞争。</p>
<h4 id="Challenge-3"><a href="#Challenge-3" class="headerlink" title="Challenge"></a>Challenge</h4><p>将零拷贝概念一直引入 lwIP。</p>
<p>一个典型的包由许多报头组成。用户在一个缓冲区中发送要传输到 lwIP 的数据。TCP 层想要添加一个 TCP 报头，IP 层需要添加一个 IP 报头，MAC 层需要添加一个以太网报头。即使一个包有许多部分，现在这些部分需要连接在一起，以便设备驱动程序可以发送最终的包。</p>
<p>E1000 的传输描述符设计非常适合于收集分散在内存中的数据包片段，比如在 lwIP 中创建的数据包片段。如果您对多个传输描述符进行排队，但只在最后一个描述符上设置 EOP 命令位，则 E1000 将从这些描述符内部连接数据包缓冲区，并且仅在连接的缓冲区到达 EOP 标记的描述符时传输连接的缓冲区。因此，各个包片段不需要在内存中连接在一起。</p>
<p>改变你的驱动程序，使之能够在不复制和修改 lwIP 的情况下发送由许多缓冲区组成的数据包，以避免像现在这样合并数据包。</p>
<h4 id="Challenge-4"><a href="#Challenge-4" class="headerlink" title="Challenge"></a>Challenge</h4><p>扩充系统调用接口以服务于多个用户环境。如果有多个网络堆栈（和多个网络服务器）在用户模式下运行，每个堆栈都有自己的IP地址，这将被证明是有用的。接收系统调用将需要决定将每个传入数据包转发到哪个环境。</p>
<p>注意，当前接口不能区分两个包之间的区别，并且如果多个环境调用包接收系统调用，则每个相应的环境将获得传入分组的子集，并且该子集可以包括未发往调用环境的分组。</p>
<p>这篇外内核论文的第 2.2 和 3 节对这个问题进行了深入的解释，并给出了在 JOS 这样的内核中解决这个问题的方法。利用这篇文章来帮助你抓住问题，很可能你不需要一个像论文中提到的那样复杂的解决方案。</p>
<h2 id="3-The-Web-Server"><a href="#3-The-Web-Server" class="headerlink" title="3. The Web Server"></a>3. The Web Server</h2><p>web 服务器以其最简单的形式将文件的内容发送到请求的客户端。我们在 user/httpd.c 中为一个非常简单的 web 服务器提供了框架代码。框架代码处理传入的连接并解析头。</p>
<h4 id="Exercise-13"><a href="#Exercise-13" class="headerlink" title="Exercise 13."></a>Exercise 13.</h4><p>web 服务器缺少处理将文件内容发送回客户端的代码。通过实现 send_file 和 send_data 来完成 web 服务器。</p>
<p>完成 web 服务器后，启动 webserver（make run-httpd-nox）并将您最喜欢的浏览器指向 <a href="http://host:port/index.html，其中">http://host:port/index.html，其中</a> host 是运行 QEMU 的计算机的名称（如果您在 athena 上运行 QEMU，请使用 hostname.mit.edu（hostname 是athena 上 hostname 命令的输出，或者 localhost（如果您在同一台计算机上运行web 浏览器和 QEMU），port 是 make which-ports为 web 服务器报告的端口号。您应该会看到一个由运行在 JOS 中的 HTTP 服务器提供服务的 web 页面。、</p>
<p>make grade 得到 105/105 。</p>
<h4 id="Challenge-5"><a href="#Challenge-5" class="headerlink" title="Challenge"></a>Challenge</h4><p>向JOS添加一个简单的聊天服务器，多个人可以连接到服务器，任何用户类型的内容都会传输给其他用户。为此，您必须找到一种方法，一次与多个套接字通信，并在同一个套接字上同时发送和接收。有多种方法可以解决这个问题。lwIP 为 recv 提供了一个 MSG_DONTWAIT 标志（请参阅 net/lwIP/api/sockets.c 中的 lwIP_recvfrom），因此您可以不断地循环所有打开的套接字，轮询它们以获取数据。请注意，虽然 recv 标志受网络服务器 IPC 的支持，但它们不能通过常规的 read 函数访问，因此需要一种方法来传递这些标志。一种更有效的方法是为每个连接启动一个或多个环境，并使用 IPC 来协调它们。方便地说，在 struct Fd 中为套接字找到的 lwIP 套接字 ID 是全局的（不是针对每个环境），因此，例如，fork 的子对象继承其父套接字。或者，环境甚至可以通过构造包含正确套接字 ID 的 Fd 发送到另一个环境的套接字。</p>
<h4 id="Question-2"><a href="#Question-2" class="headerlink" title="Question"></a>Question</h4><p>JOS的web服务器提供的web页面说明了什么？</p>
<p>你做这个实验大概花了多长时间？</p>
]]></content>
  </entry>
  <entry>
    <title>Lab 4: 抢占式多任务调度</title>
    <url>/2020/12/02/lab4/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在此 Lab 中，您将在多个同时处于活动状态的用户模式环境中实现抢占式多任务处理。</p>
<p>在 A 部分中，您将向 JOS 添加多处理器支持，实现循环调度，并添加基本环境管理系统调用（创建和销毁环境的调用，以及分配/映射内存）。</p>
<p>在 B 部分中，您将实现一个像 Unix 一样 fork()，它允许用户模式环境创建自己的副本。</p>
<p>最后，在 C 部分中，您将添加对进程间通信 （IPC） 的支持，允许不同的用户模式环境显式相互通信和同步。您还将添加对硬件时钟中断和抢占的支持。</p>
<a id="more"></a>

<h2 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h2><p>在此实验的第一部分中，您将首先扩展 JOS 以在多处理器系统上运行，然后实现一些新的 JOS 内核系统调用，以允许用户级环境创建其他新环境。您还将实现协作循环调度，允许内核在当前环境自愿放弃 CPU（或退出）时从一个环境切换到另一个环境。C 部分的稍后部分，您将实现抢占式调度，它允许内核在某个时间之后从某个环境重新控制 CPU，即使环境不配合。</p>
<h3 id="1-1-Multiprocessor-Support"><a href="#1-1-Multiprocessor-Support" class="headerlink" title="1.1 Multiprocessor Support"></a>1.1 Multiprocessor Support</h3><p>我们将使 JOS 支持”对称多处理”（SMP），这是一个多处理器模型，其中所有 CPU 都具有对内存和 I/O 总线等系统资源的等效访问权限。虽然所有 CPU 在 SMP 中功能相同，但在启动过程中，它们可以分为两种类型：引导处理器 （BSP） 负责初始化系统和启动操作系统; 而应用处理器（APs）只有在操作系统启动并运行之后才被BSP激活。哪个处理器是 BSP 由硬件和 BIOS 决定。到目前，所有现有的 JOS 代码都在 BSP 上运行。</p>
<p>在 SMP 系统中，每个 CPU 都有一个随附的本地 APIC （LAPIC） 单元。LAPIC 单元负责在整个系统中提供中断。LAPIC 还为其连接的 CPU 提供唯一标识符。在此实验中，我们使用 LAPIC 单元的以下基本功能（在 kern/lapic.c 中）：</p>
<ul>
<li>阅读 LAPIC 标识 （APIC ID），以判断我们的代码当前在哪个 CPU 上运行（请参阅 cpunum()）。</li>
<li>将启动处理器间中断 （IPI） 从 BSP 发送到 APs 以启动其他 CPU（请参见 lapic_startap() ）。</li>
<li>在 C 部分中，我们编程 LAPIC 的内置计时器以触发时钟中断，以支持抢占性多任务处理（参见 apic_init()）。</li>
</ul>
<p>处理器使用内存映射的 I/O （MMIO） 访问其 LAPIC。在 MMIO 中，物理内存的一部分被硬连线到某些 I/O 设备的寄存器，因此通常用于访问内存的相同 load/store 指令可用于访问设备寄存器。您已经在物理地址 0xA0000 看到一个 IO hole（我们用它来写入 VGA 显示缓冲区）。LAPIC 处在一个从物理地址 0xFE000000（32MB 比 4GB 短）开始的洞里，因此我们使用 KERNBASE 的常用直接映射访问该位置太高。JOS 虚拟内存在 MMIOBASE 留下了 4MB 的间隙，因此我们有一个位置可以映射这样的设备。由于以后的 Lab 引入了更多的 MMIO 区域，您将编写一个简单的函数来从该区域分配空间并将设备内存映射到该区域。</p>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1."></a>Exercise 1.</h4><p>实现 kern/pmap.c 中的 mmio_map_region。要查看如何使用此功能，请查看 kern/lapic.c lapic_init 的开始部分。在运行测试 mmio_map_region 之前，您必须完成下一练习。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 起始点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE; <span class="comment">// 0xef800000</span></span><br><span class="line">    <span class="comment">// Your code here:</span></span><br><span class="line">	<span class="keyword">size_t</span> begin = ROUNDDOWN(pa, PGSIZE);</span><br><span class="line">	<span class="keyword">size_t</span> end = ROUNDUP(pa + size, PGSIZE);</span><br><span class="line">    <span class="keyword">size_t</span> size_len = end - begin;</span><br><span class="line">	<span class="keyword">if</span> (base + size_len &gt;= MMIOLIM)&#123;</span><br><span class="line">		panic(<span class="string">&quot;memory is not enough!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	boot_map_region(kern_pgdir, base, size_len, pa, </span><br><span class="line">                    PTE_PCD|PTE_PWT|PTE_W);</span><br><span class="line">	<span class="keyword">uint32_t</span> r = base;</span><br><span class="line">	base = base + size_len;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Application-Processor-Bootstrap"><a href="#Application-Processor-Bootstrap" class="headerlink" title="Application Processor Bootstrap"></a>Application Processor Bootstrap</h4><p>在启动 AP 之前，BSP 应首先收集有关多处理器系统的信息，例如 CPU 的总数、其 APIC ID 和 LAPIC 单元的 MMIO 地址。kern/mpconfig.c 中的 mp_init()  函数通过读取驻留在 BIOS 内存区域中的 MP 配置表来检索此信息。</p>
<p>boot_aps() 函数（在 kern/init.c 中）驱动 AP 引导过程。APs 以实模式启动，与引导加载程序在 boot/boot.S 启动方式非常一样，因此 boot_aps()  复制 AP 条目代码（kern/mpentry.S） 到在实模式下可寻址的内存位置。与引导加载程序不同，我们可以控制 AP 将开始执行代码的地点; 我们将入口代码复制到 0x7000 （MPENTRY_PADDR），但任何未使用、与页面对齐的低于 640KB 的物理地址将起作用。</p>
<p>之后，boot_aps()  通过向相应 AP 的 LAPIC 单元发送 STARTUP IPI 以及初始 CS：IP 地址，AP 应在其中开始运行其输入代码 （MPENTRY_PADDR，在我们的案例中）。kern/mpentry.S 中的输入代码与 boot/boot.S 非常相似。经过一些简短的设置后，它会将 AP 置于启用分页的保护模式，然后调用 C 设置例程 mp_main()（也在 kern/init.c）。boot_aps() 等待 AP 在其结构 CpuInfo CPU_STARTED 字段中发出 cpu_status 标志信号，然后再唤醒下一个标志。</p>
<h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2."></a>Exercise 2.</h4><p>阅读 kern/init.c 中的 boot_aps() 和 mp_main()，以及 kern/mpentry.S 中的汇编代码。确保您了解在 APs 引导期间的控制流传输。然后修改 kern/pmap.c 中 page_init()  的实现，以避免在 MPENTRY_PADDR 将页面添加到空闲列表中，以便我们可以在该物理地址安全地复制和运行 AP 引导代码。您的代码应通过更新的 check_page_free_list()  测试（但可能会通不过更新的 check_kern_pgdir()测试，我们将很快修复）。</p>
<h4 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h4><ol>
<li>比较 kern/mpentry.S 和 boot/boot.S。请记住，kern/mpentry.S 编译并链接为在 KERNBASE 之上运行，就像内核中其他所有内容一样，宏 MPBOOTPHYs 的目的是什么？为什么在 kern/mpentry.S 中是必要的，但在 boot/boot.S 中却不是？换句话说，如果在 kern/mpentry.S 中省略了，会出什么问题？提示：请回顾我们在实验 1 中讨论的链接地址和加载地址之间的差异。</li>
</ol>
<h4 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h4><p>在编写多处理器操作系统时，必须区分每个处理器所私有的 CPU 状态和整个系统共享的全局状态。kern/cpu.h 定义了大部分的单 CPU 状态，包括存储 per-CPU 变量的结构 CpuInfo。cpunum() 始终返回调用它的 CPU 的 ID，该 ID 可用作像 cpus 这样的数组中的索引。或者，宏 thiscpu 是当前 CPU 结构 CpuInfo 的速记。</p>
<p>以下是您应该注意的每个 CPU 状态：</p>
<ul>
<li><p><strong>Per-CPU kernel stack</strong>.</p>
<p>由于多个 CPU 可以同时捕获到内核中，因此我们需要为每个处理器提供单独的内核堆栈，以防止它们干扰彼此的执行。数组percpu_kstacks[NCPU] KSTKSIZE]为 NCPU 的内核堆栈保留空间。</p>
<p>在 lab 2 中，您将引导堆称为 BSP 的内核堆栈映射在 KSTACKTOP 的下方。同样，在此 lab 中，您将将每个 CPU 的内核堆栈映射到此区域，保护页充当它们之间的缓冲区。CPU 0 的堆栈仍将从 KSTACKTOP 向下增长; CPU 1 的堆栈将在 CPU 0 堆栈底部下方启动 KSTKGAP 字节，等等。inc/memlayout.h 显示映射布局。</p>
</li>
<li><p><strong>Per-CPU TSS and TSS descriptor</strong>.</p>
<p>还需要一个 per-CPU 任务状态段 （TSS），以便指定每个 CPU 的内核堆栈的运行位置。CPU i 的 TSS 存储在 cpus[i].cpu_ts 中，相应的 TSS 描述符在 GDT 条目 gdt[（GD_TSS0 &gt;&gt; 3） + i] 中定义。在 kern/trap.c 中定义的全局 ts 变量将不再有用。</p>
</li>
<li><p><strong>Per-CPU current environment pointer</strong>.</p>
<p>由于每个 CPU 可以同时运行不同的用户进程，因此我们重新定义了符号 curenv 来引用 cpus[cpunum()].cpu_env (or thiscpu-&gt;cpu_env)，它指向当前 CPU 上当前执行的环境（代码正在运行的 CPU）。</p>
</li>
<li><p><strong>Per-CPU system registers</strong>.</p>
<p>所有寄存器（包括系统寄存器）都是 CPU 的私有。因此，初始化这些寄存器的指令，如 lcr3（）、ltr（）、lgdt（）、lidt（）等必须在每个 CPU 上执行一次。为此定义 env_init_percpu（）和 trap_init_percpu（）函数。</p>
</li>
</ul>
<h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3."></a>Exercise 3.</h4><p>修改 mem_init_mp() （在 kern/pmap.c） 以映射从 KSTACKTOP 开始的 per-CPU 堆栈，如 inc/memlayout.h 所示。每个堆栈的大小是 KSTKSIZE 字节加上 KSTKGAP 未映射的防护页字节。您的代码应通过新的检查check_kern_pgdir()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mem_init_mp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> kstacktop_i = KSTACKTOP - i *</span><br><span class="line">            (KSTKSIZE + KSTKGAP) - KSTKSIZE;</span><br><span class="line">    boot_map_region(kern_pgdir, kstacktop_i, KSTKSIZE, </span><br><span class="line">                    PADDR(percpu_kstacks[i]), PTE_W);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4."></a>Exercise 4.</h4><p>trap_init_percpu()（kern/trap.c） 中的代码初始化了 BSP 的 TSS 和 TSS 描述符。它在 Lab 3 中工作，但在在其他 CPU 上运行时不正确。更改代码，以便它可以处理所有 CPU。（注意：新代码不应再使用全局变量 ts。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize and load the per-CPU TSS and IDT</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init_percpu(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> this_id = thiscpu-&gt;cpu_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span> *<span class="title">this_ts</span> =</span> &amp;thiscpu-&gt;cpu_ts;</span><br><span class="line">	this_ts-&gt;ts_esp0 = KSTACKTOP - this_id * </span><br><span class="line">        						(KSTKSIZE + KSTKGAP);</span><br><span class="line">	this_ts-&gt;ts_ss0 = GD_KD;</span><br><span class="line">	this_ts-&gt;ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + this_id] = SEG16(STS_T32A, </span><br><span class="line">                 (<span class="keyword">uint32_t</span>) (this_ts),</span><br><span class="line">				 <span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + this_id].sd_s = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ltr(GD_TSS0 + (this_id &lt;&lt; <span class="number">3</span>));</span><br><span class="line">	lidt(&amp;idt_pd);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h4><p>我们当前的代码在 mp_main() 中初始化 AP 后旋转。在让 AP 更进一步之前，我们需要首先解决多个 cpu 同时运行内核代码时的竞争条件。实现这一点的最简单方法是使用大内核锁。大内核锁是一个单独的全局锁，每当环境进入内核模式时，它就被持有，当环境返回到用户模式时释放。在该模型中，用户模式下的环境可以在任何可用的cpu上并发运行，但不能有多个环境在内核模式下运行；任何其他试图进入内核模式的环境都将被迫等待。</p>
<p>kern/spinlock.h 声明大内核锁，即 kernel_lock。它还提供 lock_kernel() 和 unlock_kernel() ，用于快捷获取和释放锁。您应该在四个位置应用大内核锁：</p>
<ul>
<li>在 i386_init() 中，在 BSP 唤醒其他 CPU 之前获取锁。</li>
<li>在mp_main() 中，在初始化 AP 后获取锁，然后调用 sched_yield() 开始在此 AP 上运行环境。</li>
<li>在 trap()，从用户模式捕获时获取锁。要确定陷阱是发生在用户模式还是内核模式下，请检查 tf_cs 的低位。</li>
<li>在env_run() 中，在切换到用户模式之前释放锁。不要这样做太早或太晚，否则你会经历竞争或死锁。</li>
</ul>
<h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5."></a>Exercise 5.</h4><p>应用上述大内核锁，通过在合适的位置调用 lock_kernel() 和 unlock_kernel()。</p>
<p>如何测试您的锁是否正确？此刻你不能！但是，在下一个练习中实现调度程序后，您将能够完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i386_init()</span></span><br><span class="line">lock_kernel();</span><br><span class="line">boot_aps();</span><br><span class="line"></span><br><span class="line"><span class="comment">// mp_main()</span></span><br><span class="line">lock_kernel();</span><br><span class="line">sched_yield();</span><br><span class="line"></span><br><span class="line"><span class="comment">// trap()</span></span><br><span class="line">lock_kernel();</span><br><span class="line">assert(curenv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// env_run()</span></span><br><span class="line">unlock_kernel();</span><br><span class="line">env_pop_tf(&amp;curenv-&gt;env_tf);</span><br></pre></td></tr></table></figure>

<h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h4><ol start="2">
<li>似乎使用大内核锁可以保证一次只能运行一个内核代码。为什么我们仍然需要每个 CPU 的内核堆栈？描述使用共享内核堆栈会出错的情况，即使保护了大内核锁。</li>
</ol>
<h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>大内核锁简单易用。然而，它消除了内核模式下的所有并发性。大多数现代操作系统使用不同的锁来保护其共享状态的不同部分，这种方法称为细粒度锁。细粒度锁可以显著提高性能，但更难实现且容易出错。如果你足够勇敢，放弃大内核锁，在JOS中拥抱并发！</p>
<p>由您决定锁定粒度（锁保护的数据量）。作为提示，您可以考虑使用自旋锁来确保对 JOS 内核中的这些共享组件的独占访问：</p>
<ul>
<li>The page allocator.</li>
<li>The console driver.</li>
<li>The scheduler.</li>
<li>The inter-process communication (IPC) state that you will implement in the part C.</li>
</ul>
<h3 id="1-2-Round-Robin-Scheduling"><a href="#1-2-Round-Robin-Scheduling" class="headerlink" title="1.2 Round-Robin Scheduling"></a>1.2 Round-Robin Scheduling</h3><p>本 lab 中的下一个任务是更改 JOS 内核，以便它可以以”循环”方式在多个环境之间进行交替。JOS 中的循环调度工作原理如下：</p>
<ul>
<li>新 kern/sched.c 中的函数 sched_yield() 负责选择要运行的新环境。它按顺序搜索 envs[] 数组，从以前运行的环境（或数组的开头（如果没有以前运行的环境）开始），取它找到的状态为 ENV_RUNNABLE 的第一个环境（请参阅 inc/env.h），并调用 env_run()  跳转到该环境。</li>
<li>sched_yield()  绝不能同时在两个 CPU 上运行相同的环境。它可以判断环境当前在某些 CPU 上运行（可能是当前 CPU），因为该环境的状态将ENV_RUNNING。</li>
<li>我们已经实现了一个新的系统调用，sys_yield()，用户环境可以调用内核的 sched_yield() 函数，从而自愿放弃 CPU 给不同的环境。</li>
</ul>
<h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6."></a>Exercise 6.</h4><p>实现上文 sched_yield 中描述的循环调度。别忘了修改 syscall() 以调度sys_yield()。</p>
<p>确保在mp_main中调用sched_yield()。修改 kern/init.c 以创建三个（或更多！）运行程序 user/yield.c 的环境。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_yield(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line">    idle = curenv;</span><br><span class="line">	<span class="keyword">int</span> start_id = idle ? ENVX(idle-&gt;env_id)+<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NENV; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j = (start_id + i) % NENV;</span><br><span class="line">		<span class="keyword">if</span> (envs[j].env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">			env_run(&amp;envs[j]);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (idle &amp;&amp; idle-&gt;env_status == ENV_RUNNING) &#123;</span><br><span class="line">		env_run(idle);</span><br><span class="line">	&#125;</span><br><span class="line">    sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 make qemu。在终止之前，您应该看到环境在彼此之间来回切换五次，如下所示。</p>
<p>Test also with several CPUS: make qemu CPUS=2.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line">Hello, I am environment <span class="number">00001000.</span></span><br><span class="line">Hello, I am environment <span class="number">00001001.</span></span><br><span class="line">Hello, I am environment <span class="number">00001002.</span></span><br><span class="line">Back in environment <span class="number">00001000</span>, iteration <span class="number">0.</span></span><br><span class="line">Back in environment <span class="number">00001001</span>, iteration <span class="number">0.</span></span><br><span class="line">Back in environment <span class="number">00001002</span>, iteration <span class="number">0.</span></span><br><span class="line">Back in environment <span class="number">00001000</span>, iteration <span class="number">1.</span></span><br><span class="line">Back in environment <span class="number">00001001</span>, iteration <span class="number">1.</span></span><br><span class="line">Back in environment <span class="number">00001002</span>, iteration <span class="number">1.</span></span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>当 yield 程序退出后，系统将没有可运行的环境，调度程序应该调用 JOS 内核监视器。如果没有发生任何这种情况，请在继续之前修复代码。</p>
<h4 id="Question-2"><a href="#Question-2" class="headerlink" title="Question"></a>Question</h4><ol start="3">
<li>在 env_run() 的实现中，应该调用 lcr3()。在调用 lcr3() 之前和之后，代码将引用（至少应该）到变量 e，即 env_run 的参数。加载%cr3寄存器后，MMU 使用的寻址上下文立即更改。但虚拟地址（即 e）相对于给定地址上下文有意义——地址上下文指定虚拟地址映射到的物理地址。为什么指针 e 在寻址开关前后都能被解引用？</li>
<li>每当内核从一个环境切换到另一个环境时，它必须确保保存旧环境的寄存器，以便以后可以正确地恢复它们。为什么？在哪里发生的？</li>
</ol>
<h4 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>向内核中添加一个不那么简单的调度策略，比如一个固定优先级的调度程序，它允许为每个环境分配一个优先级，并确保总是优先选择优先级较高的环境而不是优先级较低的环境。如果你真的很有冒险精神，试着实现一个 Unix 风格的可调优先级调度程序，甚至是一个彩票调度程序或步幅调度程序。（在Google中查找“彩票调度”和“步幅调度”。）</p>
<p>编写一两个测试程序，验证调度算法是否正常工作（即，正确的环境以正确的顺序运行）。一旦在本实验室的B和C部分实现了 fork() 和 IPC，编写这些测试程序可能会更容易。</p>
<h4 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>JOS内核目前不允许应用程序使用 x86 处理器的 x87 浮点单元（FPU）、MMX指令或流单指令多数据扩展指令集（SSE）。扩展 Env 结构为处理器的浮点状态提供一个保存区域，并扩展上下文切换代码以在从一个环境切换到另一个环境时正确地保存和恢复此状态。FXSAVE 和 FXRSTOR 指令可能有用，但请注意，旧 i386 用户手册中没有这些指令，因为它们是在较新的处理器中引入的。编写一个用户级测试程序，用浮点做一些很酷的事情。</p>
<h3 id="1-3-System-Calls-for-Environment-Creation"><a href="#1-3-System-Calls-for-Environment-Creation" class="headerlink" title="1.3 System Calls for Environment Creation"></a>1.3 System Calls for Environment Creation</h3><p>尽管内核现在能够在多个用户级环境之间运行和切换，但它仍然限于内核最初设置的运行环境。现在，您将实现必要的 JOS 系统调用，以允许用户环境创建和启动其他新的用户环境。</p>
<p>Unix 提供 fork() 系统调用作为其进程创建基元。Unix fork() 复制调用进程的整个地址空间（the parent），以创建新进程（the child）。从用户空间可观察到的两个区别是它们的进程 ID 和父进程 ID（由 getpid 和 getppid 返回）。在父级中，fork() 返回子进程 ID，而在子级中，fork() 返回 0。默认情况下，每个进程都会获得自己的专用地址空间，而进程对内存的修改对另一个进程都不可见。</p>
<p>您将提供一组不同的、更原始的 JOS 系统调用，用于创建新的用户模式环境。通过这些系统调用，除了创建其他类型的环境外，您还可以完全在用户空间中实现一个与 Unix 一样的 fork()。您将为 JOS 写入的新系统调用如下所示：</p>
<p><code>sys_exofork</code>:此系统调用创建一个几乎空白的新环境：在其地址空间的用户部分不映射任何信息，并且无法运行。新环境在 sys_exofork 调用时将具有与父环境相同的寄存器状态。在父级，sys_exofork 将返回新创建环境的 envid_t 如果环境分配失败，则返回负错误代码）。但是，在子级中，它将返回 0。（由于子级开始时sys_exofork 标记为不可运行，在父级明确允许使用….）</p>
<p><code>sys_env_set_status</code>:将指定环境的状态设置为ENV_RUNNABLE或ENV_NOT_RUNNABLE。此系统调用通常用于标记一个准备运行的新环境，一旦其地址空间和寄存器状态完全初始化。</p>
<p><code>sys_page_alloc</code>: 分配物理内存的页面，并在给定环境的地址空间中的给定虚拟地址映射它。</p>
<p><code>sys_page_map</code>: 将页面映射（不是页面的内容！）从一个环境的地址空间复制到另一个环境的地址空间，保留内存共享安排，以便新映射和旧映射都引用物理内存的同一页。</p>
<p><code>sys_page_unmap</code>: 取消映射在给定环境中给定虚拟地址映射的页面。</p>
<p>对于上述接受环境 ID 的所有系统调用，JOS 内核支持值 0 表示”当前环境”的约定。本约定由 envid2env()  在 kern/env.c 中实现。</p>
<p>我们在测试程序 user/dumbfork.c 中提供了一个非常原始的 Unix 式 fork()  的实现。此测试程序使用上述系统调用创建和运行具有其自己的地址空间副本的子环境。然后，这两个环境使用 sys_yield 来回切换，如上一练习中一样。父级在 10 次迭代后退出，而子级在 20 次迭代后退出。</p>
<h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7."></a>Exercise 7.</h4><p>在 kern/syscall.c 中实现上述系统调用，并确保 syscall() 调用它们。您将需要在 kern/pmap.c 和 kern/env.c 中使用各种函数，特别是 envid2env()。现在，每当您调用 envid2env()时，在 checkperm 参数中传递 1。请确保检查是否无效的系统调用参数，在这种情况下返回 -E_INVAL。使用 user/dumbfork 测试 JOS 内核，并确保它工作后才能继续。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">envid_t</span></span><br><span class="line">sys_exofork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = env_alloc(&amp;e, curenv-&gt;env_id);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cprintf(&quot;parent_envid = %d\n&quot;, curenv-&gt;env_id);</span></span><br><span class="line">	e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	e-&gt;env_tf = curenv-&gt;env_tf;</span><br><span class="line">    </span><br><span class="line">	e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// cprintf(&quot;child_envid = %d\n&quot;, e-&gt;env_id);</span></span><br><span class="line">	<span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">	<span class="comment">// panic(&quot;sys_exofork not implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_status(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">// cprintf(&quot;sys_page_alloc here!\n&quot;);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span> </span><br><span class="line">	<span class="keyword">int</span> ret = envid2env(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	e-&gt;env_status = status;</span><br><span class="line">	<span class="comment">// cprintf(&quot;e-&gt;env_status is : %d\n&quot;, status);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// panic(&quot;sys_env_set_status not implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_alloc(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_alloc() and</span></span><br><span class="line">	<span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">	<span class="comment">//   Most of the new code you write should be to check the</span></span><br><span class="line">	<span class="comment">//   parameters for correctness.</span></span><br><span class="line">	<span class="comment">//   If page_insert() fails, remember to free the page you</span></span><br><span class="line">	<span class="comment">//   allocated!</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = envid2env(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cprintf(&quot;1\n&quot;);</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)va &gt;= UTOP || PGOFF(va)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cprintf(&quot;2\n&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((perm &amp; PTE_SYSCALL) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cprintf(&quot;3\n&quot;);</span></span><br><span class="line">	<span class="keyword">if</span> (perm &amp; ~PTE_SYSCALL)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	<span class="comment">// cprintf(&quot;4\n&quot;);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	int valid_perm = (PTE_U|PTE_P);</span></span><br><span class="line"><span class="comment">    if (va &gt;= (void *)UTOP || (perm &amp; valid_perm) != valid_perm) &#123;</span></span><br><span class="line"><span class="comment">        return -E_INVAL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> page_alloc(ALLOC_ZERO);</span><br><span class="line">	<span class="keyword">if</span> (!pp) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ret1 = page_insert(e-&gt;env_pgdir, pp, va, perm);</span><br><span class="line">	<span class="keyword">if</span> (ret1) &#123;</span><br><span class="line">		page_free(pp);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// panic(&quot;sys_page_alloc not implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_map(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span><br><span class="line">	     <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">srcpp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srce</span>, *<span class="title">dste</span>;</span></span><br><span class="line">	<span class="keyword">int</span> srcret = envid2env(srcenvid, &amp;srce, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> dstret = envid2env(dstenvid, &amp;dste, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (srcret  || dstret) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)srcva &gt;= UTOP || PGOFF(srcva) || (<span class="keyword">uint32_t</span>)dstva &gt;= UTOP || PGOFF(dstva)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((perm &amp; PTE_SYSCALL) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (perm &amp; ~PTE_SYSCALL)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	<span class="keyword">pte_t</span> *pte;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!(srcpp = page_lookup(srce-&gt;env_pgdir, srcva, &amp;pte)))</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span> (perm &amp; PTE_W) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((*pte &amp; PTE_W) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ret = page_insert(dste-&gt;env_pgdir, srcpp, dstva, perm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// panic(&quot;sys_page_map not implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_unmap(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_remove().</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = envid2env(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)va &gt;= UTOP || PGOFF(va)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	page_remove(e-&gt;env_pgdir, va);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// panic(&quot;sys_page_unmap not implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Challenge-3"><a href="#Challenge-3" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>添加读取现有环境的所有重要状态并设置它所需的其他系统调用。然后实现一个用户模式程序，该程序将分叉掉子环境，运行它一段时间（例如，sys_yield() 的几次迭代），然后对子环境进行完整快照或设置检查点，将子环境运行更长时间，最后将子环境还原到检查点的状态，并从那里继续。因此，您实际上是从中间状态执行子环境。使子环境使用 sys_cgetc() 或 readline() 与用户执行一些交互，以便用户可以查看和更改其内部状态，并验证使用检查点/重新启动时，您可以给子环境提供选择性健忘症的情况，使其”忘记”在某个点之外发生的一切。</p>
<h2 id="Part-B-Copy-on-Write-Fork"><a href="#Part-B-Copy-on-Write-Fork" class="headerlink" title="Part B: Copy-on-Write Fork"></a>Part B: Copy-on-Write Fork</h2><h3 id="2-1-User-level-page-fault-handlin"><a href="#2-1-User-level-page-fault-handlin" class="headerlink" title="2.1 User-level page fault handlin"></a>2.1 User-level page fault handlin</h3><p>用户级 写时复制 fork() 需要知道写保护页上的页错误，因此这是您首先要实现的。写时复制只是用户级页面错误处理的许多可能用途之一。</p>
<p>通常设置一个地址空间，以便页面错误指示何时需要执行某些操作。例如，大多数 Unix 内核最初只映射一个新进程的堆栈区域中的一个页面，当进程的堆栈消耗增加并导致尚未映射的堆栈地址出现页面错误时，会在以后“按需”分配和映射其他堆栈页。典型的 Unix 内核必须跟踪进程空间的每个区域发生页错误时要采取的操作。例如，堆栈区域中的错误通常会分配和映射物理内存的新页。程序的 BSS 区域中的错误通常会分配一个新页，用零填充，然后映射它。在具有按需分页可执行文件的系统中，文本区域中的错误将从磁盘上读取二进制文件的相应页，然后将其映射。</p>
<p>这是内核需要跟踪的大量信息。与传统的Unix方法不同，您将决定如何处理用户空间中的每一个页面错误，其中 bug 的破坏性更小。这种设计的另一个好处是允许程序在定义其内存区域时具有很大的灵活性；稍后将使用用户级页面错误处理来映射和访问基于磁盘的文件系统上的文件。</p>
<h4 id="Setting-the-Page-Fault-Handler"><a href="#Setting-the-Page-Fault-Handler" class="headerlink" title="Setting the Page Fault Handler"></a>Setting the Page Fault Handler</h4><p>为了处理自己的页面错误，用户环境需要向 JOS 内核注册一个页面错误处理程序入口点。用户环境通过新的 sys_env_set_pgfault_upcall 系统调用注册其页面错误入口点。我们在 Env 结构中添加了一个新成员 Env_pgfault_upcall，以记录此信息。</p>
<h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8."></a>Exercise 8.</h4><p>实现系统调用 sys_env_set_pgfault_upcall。在查找目标环境的环境 ID 时，一定要启用权限检查，因为这是一个“危险”的系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_pgfault_upcall(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *func)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (envid2env(envid, &amp;e, <span class="number">1</span>)) <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	e-&gt;env_pgfault_upcall = func;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// panic(&quot;sys_env_set_pgfault_upcall not implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Normal-and-Exception-Stacks-in-User-Environments"><a href="#Normal-and-Exception-Stacks-in-User-Environments" class="headerlink" title="Normal and Exception Stacks in User Environments"></a>Normal and Exception Stacks in User Environments</h4><p>在正常执行期间，JOS 中的用户环境将在正常用户堆栈上运行：它的 ESP 寄存器开始指向 USTACKTOP，它推送的堆栈数据驻留在 USTACKTOP - PGSIZE 和 USTACKTOP - 1 之间的页面上。但是，当在用户模式下发生页面错误时，内核将重新启动用户环境，在另一个堆栈（即用户异常堆栈）上运行指定的用户级页面错误处理程序。本质上，我们将让 JOS 内核代表用户环境实现自动的“堆栈切换”，就像 x86 处理器在从用户模式转换到内核模式时已经代表 JOS 实现了堆栈切换一样！</p>
<p>JOS 用户异常堆栈的大小也是一个页面，其顶部被定义为位于虚拟地址UXSTACKTOP，因此用户异常堆栈的有效字节是从 UXSTACKTOP -P GSIZE 到UXSTACKTOP-1（含）。在这个异常堆栈上运行时，用户级页面错误处理程序可以使用 JOS 的常规系统调用来映射新页面或调整映射，从而修复最初导致页面错误的任何问题。然后，用户级页面错误处理程序通过汇编语言存根返回到原始堆栈上的错误代码。</p>
<p>希望支持用户级页面错误处理的每个用户环境都需要使用第 A 部分中介绍的sys_page_alloc()  系统调用为自己的异常堆栈分配内存。</p>
<h4 id="Invoking-the-User-Page-Fault-Handler"><a href="#Invoking-the-User-Page-Fault-Handler" class="headerlink" title="Invoking the User Page Fault Handler"></a>Invoking the User Page Fault Handler</h4><p>现在您需要更改 kern/trap.c 中的页面错误处理代码，以便从用户模式处理页面错误，如下所示。我们将故障发生时用户环境的状态称为 trap-time 状态。</p>
<p>如果没有注册页面错误处理程序，JOS 内核会 像以前一样用一条消息破坏用户环境。否则，内核在异常堆栈上设置一个 trap frame，它看起来像 inc/trap.h 中的struct UTrapframe：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">                    &lt;-- UXSTACKTOP</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time eflags</span><br><span class="line">trap-time eip</span><br><span class="line">trap-time eax       start of <span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span></span></span><br><span class="line"><span class="class"><span class="title">trap</span>-<span class="title">time</span> <span class="title">ecx</span></span></span><br><span class="line"><span class="class"><span class="title">trap</span>-<span class="title">time</span> <span class="title">edx</span></span></span><br><span class="line"><span class="class"><span class="title">trap</span>-<span class="title">time</span> <span class="title">ebx</span></span></span><br><span class="line"><span class="class"><span class="title">trap</span>-<span class="title">time</span> <span class="title">esp</span></span></span><br><span class="line"><span class="class"><span class="title">trap</span>-<span class="title">time</span> <span class="title">ebp</span></span></span><br><span class="line"><span class="class"><span class="title">trap</span>-<span class="title">time</span> <span class="title">esi</span></span></span><br><span class="line"><span class="class"><span class="title">trap</span>-<span class="title">time</span> <span class="title">edi</span>       <span class="title">end</span> <span class="title">of</span> <span class="keyword">struct</span> <span class="title">PushRegs</span></span></span><br><span class="line"><span class="class"><span class="title">tf_err</span> (<span class="title">error</span> <span class="title">code</span>)</span></span><br><span class="line"><span class="class"><span class="title">fault_va</span>            &lt;</span>-- %esp when handler is run</span><br></pre></td></tr></table></figure>

<p>然后，内核安排用户环境恢复执行，并在异常堆栈上运行带有此堆栈框架的页面错误处理程序；您必须弄清楚如何实现这一点。fault_va 是导致页面错误的虚拟地址。</p>
<p>如果发生异常时用户环境已在用户异常堆栈上运行，则页面错误处理程序本身已出现故障。在这种情况下，您应该在当前 tf-&gt;tf_esp 下而不是在 UXSTACKTOP 下启动新的堆栈帧。您应该首先推送一个空的 32 位字，然后再推送 struct UTrapframe。</p>
<p>要测试 tf-&gt;tf_esp 是否已经在用户异常堆栈上，请检查它是否在 UXSTACKTOP-PGSIZE 和 UXSTACKTOP-1 之间的范围内。</p>
<h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9."></a>Exercise 9.</h4><p>在 kern/trap.c 中的 page_fault_handler 程序中实现将 页错误分派给用户模式处理程序 所需的代码。在写入异常堆栈时，一定要采取适当的预防措施。（如果异常堆栈上的用户环境空间不足，会发生什么情况？）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> *<span class="title">utf</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (curenv-&gt;env_pgfault_upcall) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE &amp;&amp; tf-&gt;tf_esp &lt; UXSTACKTOP) &#123;</span><br><span class="line">			utf = (struct UTrapframe *)(tf-&gt;tf_esp - <span class="number">4</span> - <span class="keyword">sizeof</span>(struct UTrapframe));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			utf = (struct UTrapframe *)(UXSTACKTOP - <span class="keyword">sizeof</span>(struct UTrapframe));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		user_mem_assert(curenv, (<span class="keyword">void</span> *) utf, <span class="keyword">sizeof</span>(struct UTrapframe), PTE_W | PTE_P);</span><br><span class="line"></span><br><span class="line">		utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">		utf-&gt;utf_err = tf-&gt;tf_trapno;</span><br><span class="line">		utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">		utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">		utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">		utf-&gt;utf_esp = tf-&gt;tf_esp;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		tf-&gt;tf_esp = (<span class="keyword">uint32_t</span>)utf;</span><br><span class="line">		tf-&gt;tf_eip = (<span class="keyword">uint32_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">		env_run(curenv);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="User-mode-Page-Fault-Entrypoint"><a href="#User-mode-Page-Fault-Entrypoint" class="headerlink" title="User-mode Page Fault Entrypoint"></a>User-mode Page Fault Entrypoint</h4><p>接下来，您需要实现程序集例程，该例程负责调用 C 页错误处理程序并在原始错误指令处恢复执行。此程序集例程是将使用 sys_env_set_pgfault_upcall() 向内核注册的处理程序。</p>
<h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10."></a>Exercise 10.</h4><p>在 lib/pfentry.S 中实现 _pgfault_upcall 例程。有趣的部分是回到导致页面错误的用户代码的原点。您将直接返回到那里，而不必返回内核。最困难的部分是同时切换堆栈和重新加载 EIP。</p>
<p>最后，您需要实现 用户级页面错误处理机制 的 C 用户库端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 汇编语言不熟练，此处借鉴</span></span><br></pre></td></tr></table></figure>

<h4 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11."></a>Exercise 11.</h4><p>在 lib/pgfault.c 中完成 set_pgfault_handler()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">set_pgfault_handler(<span class="keyword">void</span> (*handler)(struct UTrapframe *utf))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// First time through!</span></span><br><span class="line">		<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">		<span class="keyword">int</span> r = sys_page_alloc(<span class="number">0</span>, (<span class="keyword">void</span> *)(UXSTACKTOP - PGSIZE), PTE_SYSCALL);</span><br><span class="line">		<span class="keyword">if</span> (r) panic(<span class="string">&quot;set_pgfault_handler:%e&quot;</span>, r);</span><br><span class="line">		sys_env_set_pgfault_upcall(<span class="number">0</span>, _pgfault_upcall);</span><br><span class="line">		<span class="comment">// panic(&quot;set_pgfault_handler not implemented&quot;);</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">	_pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h4><p>Run <code>user/faultread</code> (make run-faultread). You should see:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[<span class="number">00000000</span>] <span class="keyword">new</span> env <span class="number">00001000</span></span><br><span class="line">[<span class="number">00001000</span>] user fault va <span class="number">00000000</span> ip <span class="number">0080003</span>a</span><br><span class="line">TRAP frame ...</span><br><span class="line">[<span class="number">00001000</span>] <span class="built_in">free</span> env <span class="number">00001000</span></span><br></pre></td></tr></table></figure>

<p>Run <code>user/faultdie</code>. You should see:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[<span class="number">00000000</span>] <span class="keyword">new</span> env <span class="number">00001000</span></span><br><span class="line">i faulted at va deadbeef, err <span class="number">6</span></span><br><span class="line">[<span class="number">00001000</span>] exiting gracefully</span><br><span class="line">[<span class="number">00001000</span>] <span class="built_in">free</span> env <span class="number">00001000</span></span><br></pre></td></tr></table></figure>

<p>Run <code>user/faultalloc</code>. You should see:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[<span class="number">00000000</span>] <span class="keyword">new</span> env <span class="number">00001000</span></span><br><span class="line">fault deadbeef</span><br><span class="line"><span class="keyword">this</span> <span class="built_in">string</span> was faulted in at deadbeef</span><br><span class="line">fault cafebffe</span><br><span class="line">fault cafec000</span><br><span class="line"><span class="keyword">this</span> <span class="built_in">string</span> was faulted in at cafebffe</span><br><span class="line">[<span class="number">00001000</span>] exiting gracefully</span><br><span class="line">[<span class="number">00001000</span>] <span class="built_in">free</span> env <span class="number">00001000</span></span><br></pre></td></tr></table></figure>

<p>如果您只看到第一行 “this string”，这意味着您没有正确处理递归页错误。</p>
<p>Run <code>user/faultallocbad</code>. You should see:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[<span class="number">00000000</span>] <span class="keyword">new</span> env <span class="number">00001000</span></span><br><span class="line">[<span class="number">00001000</span>] user_mem_check assertion failure <span class="keyword">for</span> va deadbeef</span><br><span class="line">[<span class="number">00001000</span>] <span class="built_in">free</span> env <span class="number">00001000</span></span><br></pre></td></tr></table></figure>

<p>确保您理解 user/faultalloc 和 user/faultallocbad 行为不同的原因。</p>
<h4 id="Challenge-4"><a href="#Challenge-4" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>扩展内核，这样不仅页面错误，而且用户空间中运行的代码可以生成的所有类型的处理器异常都可以重定向到用户模式异常处理程序。编写用户模式测试程序来测试用户模式对各种异常的处理，例如除零、一般保护故障和非法操作码。</p>
<h3 id="2-2-Implementing-Copy-on-Write-Fork"><a href="#2-2-Implementing-Copy-on-Write-Fork" class="headerlink" title="2.2 Implementing Copy-on-Write Fork"></a>2.2 Implementing Copy-on-Write Fork</h3><p>现在您有了完全在用户空间中实现 copy on write fork（） 的内核工具。</p>
<p>我们在 lib/fork.c 中为 fork（） 提供了一个框架。与 dumbfork（）一样，fork（）应该创建一个新环境，然后扫描父环境的整个地址空间，并在子环境中设置相应的页映射。关键区别在于，虽然 dumbfork（）复制了页面，但 fork（）最初只复制页面映射。fork（）将仅在其中一个环境尝试写入每一页时复制该页。</p>
<p>fork（）的基本控制流程如下：</p>
<ol>
<li><p>父级使用上面实现的 set_pgfault_handler() 函数将 pgfault() 安装为 C 级页面错误处理程序。                                                                                                                                                                                                                                                                                                                                                                                        </p>
</li>
<li><p>父级调用 sys_exofork() 来创建子环境。</p>
</li>
<li><p>对于 UTOP 下其地址空间中的每个可写页或写时副本页，父级调用 duppage，它应将写入时的页副本映射到子级的地址空间，然后在自己的地址空间中重新映射“写时复制”页。[注：此处的排序（即在子页面中标记为 COW，然后在父页面中标记该页面）实际上很重要！你知道为什么吗？试着想一个具体的例子，在这种情况下，颠倒顺序可能会引起麻烦。] duppage 设置两个 PTE，使页面不可写，并在“avail”字段中包含 PTE_COW，以区分写时复制页和真正的只读页。</p>
<p>但是，异常堆栈不会以这种方式重新映射。相反，您需要为异常堆栈在子级中分配一个新页。由于页错误处理程序将执行实际的复制操作，而页错误处理程序在异常堆栈上运行，因此无法在写入时复制异常堆栈：谁会复制它？</p>
<p>fork() 还需要处理存在但不可写或写时复制的页。</p>
</li>
<li><p>父级为子级设置用户页错误入口点，使其看起来像自己的。</p>
</li>
<li><p>子进程现在可以运行了，因此父进程将其标记为可运行的。</p>
</li>
</ol>
<p>每当一个环境在写入页上写入一个尚未写入的副本时，它将出现一个页面错误。以下是用户页面错误处理程序的控制流：</p>
<ol>
<li>内核将页面错误传播到 _pgfault_upcall，后者调用 fork() 的 pgfault() 处理程序。</li>
<li>pgfault() 检查错误是否为 write（检查错误代码中的 FEC_WR），以及页面的 PTE 是否标记为 PTE_COW。如果没有，就 panic。</li>
<li>pgfault() 分配在临时位置映射的新页，并将出错页的内容复制到其中。然后，错误处理程序将新页面映射到具有读/写权限的适当地址，而不是原来的只读映射。</li>
</ol>
<p>用户级 lib/fork.c 代码必须参考环境的页表来执行上述操作（例如，页面的 PTE 标记为 PTE_COW）。内核正是为了这个目的在 UVPT 映射环境的页表。它使用了一个巧妙的映射技巧，使得查找 pte 以查找用户代码变得更加容易。lib/entry.S 设置uvpt 和 uvpd，以便您可以轻松地在 lib/fork.c 中查找页表信息。</p>
<h4 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12."></a>Exercise 12.</h4><p>在 lib/fork.c 中实现 fork、duppage 和 pgfault。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">envid_t</span></span><br><span class="line">fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> *<span class="title">utf</span>;</span></span><br><span class="line">	<span class="keyword">envid_t</span> envid;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">uint32_t</span> pn;</span><br><span class="line"></span><br><span class="line">	set_pgfault_handler(pgfault);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	envid = sys_exofork();</span><br><span class="line">	<span class="keyword">if</span> (envid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		panic(<span class="string">&quot;sys_exofork: %e\n&quot;</span>, envid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// child</span></span><br><span class="line">		thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We&#x27;re the parent.</span></span><br><span class="line">	<span class="comment">// Copy our address space and page fault handler setup to the child.</span></span><br><span class="line">	<span class="keyword">for</span> (pn = PGNUM(UTEXT); pn &lt; PGNUM(USTACKTOP); pn++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((uvpd[pn &gt;&gt; <span class="number">10</span>] &amp; PTE_P ) &amp;&amp; (uvpt[pn] &amp; PTE_P)) &#123;</span><br><span class="line">			<span class="comment">// Here has a problem.</span></span><br><span class="line">			<span class="keyword">if</span> ((r = duppage(envid, pn)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				panic(<span class="string">&quot;duppage fault: %e\n&quot;</span>, r);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Alloc a page for the exception stack.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_alloc(envid, (<span class="keyword">void</span> *)(UXSTACKTOP - PGSIZE), PTE_U | PTE_P |PTE_W)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		panic(<span class="string">&quot;sys_page_alloc: %e\n&quot;</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall(<span class="keyword">void</span>);</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_env_set_pgfault_upcall(envid, _pgfault_upcall) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">		panic(<span class="string">&quot;sys_env_set_pgfault_upcall: %e\n&quot;</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the child environment running</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		panic(<span class="string">&quot;sys_env_set_status: %e\n&quot;</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> envid;</span><br><span class="line">	<span class="comment">// panic(&quot;fork not implemented&quot;);</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	bool er = uvpt[pn] &amp; PTE_W;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	if (er) &#123;</span></span><br><span class="line"><span class="comment">		cprintf(&quot;yes\n&quot;);</span></span><br><span class="line"><span class="comment">	&#125; else &#123;</span></span><br><span class="line"><span class="comment">		cprintf(&quot;no\n&quot;);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">// cprintf(&quot;%d\n&quot;, thisenv-&gt;env_id);</span></span><br><span class="line">	<span class="comment">// cprintf(&quot;%x\n&quot;, uvpt[pn]);</span></span><br><span class="line">	<span class="comment">// cprintf(&quot;pgfault\n&quot;);</span></span><br><span class="line">	<span class="keyword">if</span> ((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW)) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)(pn*PGSIZE), envid, (<span class="keyword">void</span> *)(pn*PGSIZE), PTE_COW | PTE_P | PTE_U)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			panic(<span class="string">&quot;sys_page_map: %e\n&quot;</span>, r);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)(pn*PGSIZE), <span class="number">0</span>, (<span class="keyword">void</span> *)(pn*PGSIZE), PTE_COW | PTE_P | PTE_U)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			panic(<span class="string">&quot;sys_page_map: %e\n&quot;</span>, r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)(pn*PGSIZE), envid, (<span class="keyword">void</span> *)(pn*PGSIZE),  PTE_COW | PTE_P | PTE_U)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			panic(<span class="string">&quot;sys_page_map: %e\n&quot;</span>, r);</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// panic(&quot;duppage not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">	<span class="keyword">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!((err &amp; FEC_WR) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_COW) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp; (uvpd[PDX(addr)] &amp; PTE_P))) &#123;</span><br><span class="line">	 	panic(<span class="string">&quot;faulting access was not (1) a write, and (2) to a copy-on-write page.&quot;</span>);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_alloc(sys_getenvid(), (<span class="keyword">void</span> *)PFTEMP, PTE_P|PTE_U|PTE_W) )&lt; <span class="number">0</span>) &#123;</span><br><span class="line">		panic(<span class="string">&quot;pgfault:allocating at %x in page fault handler: %e&quot;</span>, addr, r);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="keyword">void</span> *)PFTEMP, (<span class="keyword">const</span> <span class="keyword">void</span> *)(ROUNDDOWN(addr, PGSIZE)), PGSIZE);</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_map(sys_getenvid(), (<span class="keyword">void</span> *)PFTEMP, sys_getenvid(), (<span class="keyword">void</span> *)(ROUNDDOWN(addr, PGSIZE)), PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		panic(<span class="string">&quot;pgfault:sys_page_map: %e\n&quot;</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_unmap(sys_getenvid(),(<span class="keyword">void</span> *)PFTEMP)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		panic(<span class="string">&quot;pgfault:sys_page_unmap: %e\n&quot;</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// panic(&quot;pgfault not implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 forktree 程序测试代码。它应该生成以下消息，其中穿插着 “new env”、“free env” 和 “exiting gracefully” 消息。消息可能不会按此顺序出现，并且环境 ID 可能不同。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="number">1000</span>: I am <span class="string">&#x27;&#x27;</span></span><br><span class="line">1001: I am &#x27;0&#x27;</span><br><span class="line">2000: I am &#x27;00&#x27;</span><br><span class="line">2001: I am &#x27;000&#x27;</span><br><span class="line"><span class="number">1002</span>: I am <span class="string">&#x27;1&#x27;</span></span><br><span class="line">3000: I am &#x27;11&#x27;</span><br><span class="line">3001: I am &#x27;10&#x27;</span><br><span class="line">4000: I am &#x27;100&#x27;</span><br><span class="line">1003: I am &#x27;01&#x27;</span><br><span class="line">5000: I am &#x27;010&#x27;</span><br><span class="line">4001: I am &#x27;011&#x27;</span><br><span class="line">2002: I am &#x27;110&#x27;</span><br><span class="line">1004: I am &#x27;001&#x27;</span><br><span class="line">1005: I am &#x27;111&#x27;</span><br><span class="line">1006: I am &#x27;101&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="Challenge-5"><a href="#Challenge-5" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>实现名为 sfork() 的共享内存 fork()。这个版本应该让父级和子级共享它们的所有内存页（因此在一个环境中的写入会出现在另一个环境中），除了堆栈区域中的页之外，这些页应该以通常的“写入时复制”方式处理。修改 user/forktree.c 以使用sfork() 而不是常规的 fork()。另外，在 C 部分中完成 IPC 的实现之后，使用 sfork()来运行 user/pingpongs。您必须找到一种新的方法来提供全局 thisenv 指针的功能。</p>
<h4 id="Challenge-6"><a href="#Challenge-6" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>fork 的实现会进行大量的系统调用。在 x86 上，使用中断切换到内核的代价不小。扩充系统调用接口，以便可以一次发送一批系统调用。然后更改 fork 以使用此接口。</p>
<p>你的新 fork 快多少？</p>
<p>您可以通过使用分析参数来估计批处理系统调用对 fork 性能的改善程度（粗略地）来回答这个问题：int 0x30 指令有多贵？在 fork 中执行 int 0x30 多少次？访问TSS堆栈交换机也很昂贵吗？等等。。。</p>
<p>或者，您可以在真正的硬件上引导内核，并真正地对代码进行基准测试。请参阅IA32 手册中定义的 RDTSC（读取时间戳计数器）指令，该指令统计自上次处理器重置以来经过的时钟周期数。QEMU 不能忠实地模拟这个指令（它可以计算执行的虚拟指令的数量，也可以使用主机 TSC，这两者都不能反映实际 CPU 需要的周期数）。</p>
<h2 id="Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><a href="#Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC" class="headerlink" title="Part C: Preemptive Multitasking and Inter-Process communication (IPC)"></a>Part C: Preemptive Multitasking and Inter-Process communication (IPC)</h2><p>在 Lab 4 的最后一部分，您将修改内核以抢占不合作环境，并允许环境将消息显式传递给对方。</p>
<h3 id="3-1-Clock-Interrupts-and-Preemption"><a href="#3-1-Clock-Interrupts-and-Preemption" class="headerlink" title="3.1 Clock Interrupts and Preemption"></a>3.1 Clock Interrupts and Preemption</h3><p>运行 user/spin 测试程序。此测试程序从子环境中分叉，一旦它获得 CPU 的控制，子环境就永远在紧密循环中旋转。父环境和内核都无法恢复 CPU。在用户模式环境中，这显然不是保护系统免受错误或恶意代码影响的理想情况，因为任何用户模式环境都可以通过进入无限循环而使整个系统停止，并且从不返回 CPU。为了让内核抢占运行环境的先机，强制从它重新控制 CPU，我们必须扩展 JOS 内核以支持时钟硬件的外部硬件中断。</p>
<h4 id="Interrupt-discipline"><a href="#Interrupt-discipline" class="headerlink" title="Interrupt discipline"></a>Interrupt discipline</h4><p>外部中断（即设备中断）称为 IRQ。有 16 个可能的 IRQ，编号为 0 到 15。从 IRQ 编号到 IDT 条目的映射不是固定的。picirq.c 中的 pic_init 将 IRQs 0-15 映射到 IDT 条目 IRQ_OFFSET 通过 IRQ_OFFSET+15。</p>
<p>在 inc/trap.h 中，IRQ_OFFSET 定义为十进制 32。因此，IDT 条目 32-47 对应于 IRQs 0-15。例如，时钟中断为 IRQ 0。因此，IDT[IRQ_OFFSET+0]（即 IDT[32]）包含内核中时钟的中断处理程序例程的地址。选择 IRQ_OFFSET，以便设备中断不会与处理器异常重叠，否则显然会导致混淆。（事实上，在运行 MS-DOS 的 PC 的早期，IRQ_OFFSET 实际上为零，这确实在处理硬件中断和处理处理器异常之间造成了巨大的混乱！）</p>
<p>在 JOS 中，与 xv6 Unix 相比，我们进行密钥简化。在内核中始终禁用外部设备中断（就像 xv6 在用户空间中启用）。外部中断由 %eflags 寄存器 FL_IF 标记位控制（参见 inc/mmu.h）。设置此位时，将启用外部中断。虽然可以通过多种方式修改位，但由于我们的简化，只有我们进入和离开用户模式时，我们仅通过保存和恢复 %eflags 寄存器的过程来处理它。</p>
<p>您必须确保 FL_IF 标志在用户环境中运行时设置，以便当中断到达时，该标志会传递到处理器并由中断代码处理。否则，中断将被屏蔽或忽略，直到重新启用中断。我们用引导加载程序的第一个指令屏蔽了中断，到目前为止，我们从未绕过重新启用它们。</p>
<h4 id="Exercise-13"><a href="#Exercise-13" class="headerlink" title="Exercise 13."></a>Exercise 13.</h4><p>修改 kern/trapentry.S 和 kern/trap.c 初始化 IDT 中的适当条目，并为 IRQ 0 到 15 提供处理程序。然后修改 kern/env.c 中 env_alloc() 中的代码，以确保用户环境始终在启用中断的情况下运行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(V_TIMER, IRQ_TIMER + IRQ_OFFSET);</span><br><span class="line">TRAPHANDLER_NOEC(V_KBD, IRQ_KBD + IRQ_OFFSET);</span><br><span class="line">TRAPHANDLER_NOEC(V_SERIAL, IRQ_SERIAL + IRQ_OFFSET);</span><br><span class="line">TRAPHANDLER_NOEC(V_SPURIOUS, IRQ_SPURIOUS + IRQ_OFFSET);</span><br><span class="line">TRAPHANDLER_NOEC(V_IDE, IRQ_IDE + IRQ_OFFSET);</span><br><span class="line">TRAPHANDLER_NOEC(V_ERROR, IRQ_ERROR + IRQ_OFFSET);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Hardware IRQ </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_TIMER</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_KBD</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_SERIAL</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_SPURIOUS</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_IDE</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">V_ERROR</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], <span class="number">0</span>, GD_KT, V_TIMER, <span class="number">3</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + IRQ_KBD], <span class="number">0</span>, GD_KT, V_KBD, <span class="number">3</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL], <span class="number">0</span>, GD_KT, V_SERIAL, <span class="number">3</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], <span class="number">0</span>, GD_KT, V_SPURIOUS, <span class="number">3</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + IRQ_IDE], <span class="number">0</span>, GD_KT, V_IDE, <span class="number">3</span>);</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], <span class="number">0</span>, GD_KT, V_ERROR, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，取消注释 sched_halt() 中的 sti 指令，以便空闲 CPU 取消屏蔽中断。</p>
<p>处理器在调用硬件中断处理程序时从不推送错误代码。</p>
<p>完成本练习后，如果使用运行时间不长（例如 spin）的任何测试程序运行内核，您应该会看到硬件中断的内核打印陷阱帧。虽然现在在处理器中启用了中断，但 JOS 尚未处理它们，因此您应该看到它将每个中断错误地归于当前正在运行的用户环境并销毁它。最终，它应该耗尽环境以破坏之并进入监视器。</p>
<h4 id="Handling-Clock-Interrupts"><a href="#Handling-Clock-Interrupts" class="headerlink" title="Handling Clock Interrupts"></a>Handling Clock Interrupts</h4><p>在 user/spin 程序中，在第一次运行子环境之后，它只是在一个循环中旋转，内核再也没有得到控制权。我们需要对硬件进行编程，使其周期性地产生时钟中断，这将迫使控制权回到内核，在那里我们可以将控制权切换到不同的用户环境。</p>
<p>我们为您编写的 lapic_init 和 pic_init（来自 init.c 中的 i386_init）的调用设置了时钟和中断控制器以生成中断。</p>
<h4 id="Exercise-14"><a href="#Exercise-14" class="headerlink" title="Exercise 14."></a>Exercise 14.</h4><p>修改内核的 trap_dispatch() 函数，使其在时钟中断发生时调用 sched_yield() 来查找并运行不同的环境。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</span><br><span class="line">		lapic_eoi();</span><br><span class="line">		sched_yield();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在您应该能够让 user/spin 测试正常工作：父环境应该将子环境分离，sys_yield()为其调度几次，但在每种情况下，在一个时间片之后重新获得对 CPU 的控制，最后终止子环境并优雅地终止。</p>
<p>现在是进行回归测试的好时机。通过启用中断，确保您没有破坏实验室的任何早期部分（例如 forktree）。另外，尝试使用 make CPUS=2 运行多个 cpu。你现在也应该能够通过压力测试了。运行 make grade 查看。你现在应该在这个实验中得到 65/80 分的总分。</p>
<h3 id="3-2-Inter-Process-communication-IPC"><a href="#3-2-Inter-Process-communication-IPC" class="headerlink" title="3.2 Inter-Process communication (IPC)"></a>3.2 Inter-Process communication (IPC)</h3><p>进程间通信有许多模型。即使在今天，关于哪种模式是最好的仍有争论。我们不会再讨论这个问题了。相反，我们将实现一个简单的 IPC 机制，然后进行尝试。</p>
<h4 id="IPC-in-JOS"><a href="#IPC-in-JOS" class="headerlink" title="IPC in JOS"></a>IPC in JOS</h4><p>您将实现一些额外的 JOS 内核系统调用，这些调用共同提供了一个简单的进程间通信机制。您将实现两个系统调用：sys_ipc_recv 和 sys_ipc_try_send。</p>
<p>用户环境可以使用 JOS 的 IPC 机制相互发送的“消息”由两个组件组成：一个 32 位值和一个可选的单页映射。允许环境在消息中传递页映射提供了一种高效的方法来传输比单个 32 位整数容纳的更多的数据，还允许环境轻松地设置共享内存安排。</p>
<h4 id="Sending-and-Receiving-Messages"><a href="#Sending-and-Receiving-Messages" class="headerlink" title="Sending and Receiving Messages"></a>Sending and Receiving Messages</h4><p>要接收消息，环境调用 sys_ipc_recv。此系统调用取消当前环境的计划，并且在收到消息之前不会再次运行它。当环境正在等待接收消息时，任何其他环境都可以向其发送消息—不仅是特定环境，而且不只是与接收环境具有父/子关系的环境。换言之，您在第 A 部分中实现的权限检查将不适用于 IPC，因为 IPC 系统调用是经过精心设计的“安全”的：一个环境不能仅仅通过发送消息就导致另一个环境发生故障（除非目标环境也有问题）。</p>
<p>要尝试发送一个值，环境调用 sys_ipc_try_send，同时使用接收方的环境 id 和要发送的值。如果命名环境实际正在接收（它已调用 sys_ipc_recv，但尚未获得值），则 send 将传递消息并返回 0。否则，发送返回 -E_IPC_NOT_RECV，指示目标环境当前不希望接收值。</p>
<p>用户空间中的库函数 ipc_recv 将负责调用 sys_ipc_recv，然后在当前环境的 struct Env 中查找有关接收到的值的信息。</p>
<p>类似地，库函数 ipc_send 将负责反复调用 sys_ipc_try_send，直到发送成功。</p>
<h4 id="Transferring-Pages"><a href="#Transferring-Pages" class="headerlink" title="Transferring Pages"></a>Transferring Pages</h4><p>当环境使用有效的 dstva 参数（在 UTOP 下面）调用 sys_ipc_recv 时，环境声明它愿意接收页面映射。如果发送方发送一个页面，那么该页面应该映射到接收方地址空间中的 dstva。如果接收方已经在 dstva 映射了一个页面，那么前一个页面将被取消映射。</p>
<p>当环境使用有效的 srcva（在UTOP下）调用 sys_ipc_try_send 时，这意味着发送方希望将当前映射到 srcva 的页面发送到接收方，并具有 perm 权限。在成功的 IPC 之后，发送方在 srcva 的地址空间中保留了它在 srcva 的页的原始映射，但是接收方也在接收方的地址空间中，在接收方最初指定的 dstva 处获得同一物理页的映射。因此，此页面将在发送方和接收方之间共享。</p>
<p>如果发送方或接收方都未指明应传输页面，则不传输任何页面。在任何 IPC 之后，内核将接收方 env 结构中的新字段 env_IPC_perm 设置为接收到的页面的权限，如果没有收到页面，则设置为零。</p>
<h4 id="Implementing-IPC"><a href="#Implementing-IPC" class="headerlink" title="Implementing IPC"></a>Implementing IPC</h4><h4 id="Exercise-15"><a href="#Exercise-15" class="headerlink" title="Exercise 15."></a>Exercise 15.</h4><p>实现 kern/syscall.c 中的 <code>sys_ipc_recv</code> and <code>sys_ipc_try_send</code>。在实施它们之前，请先阅读这两个方面的评论，因为它们必须协同工作。当您在这些例程中调用 envid2env 时，应该将 checkperm 标志设置为0，这意味着允许任何环境向任何其他环境发送 IPC 消息，并且内核除了验证目标 envid 是否有效外，不执行任何特殊权限检查。、</p>
<p>实现 <code>lib/ipc.c</code> 中的 <code>ipc_recv</code> and <code>ipc_send</code> 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ipc_send(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">// panic(&quot;ipc_send not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">if</span> (!pg) &#123;</span><br><span class="line">		pg = (<span class="keyword">void</span> *)UTOP;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">while</span> ((r = sys_ipc_try_send(to_env, val, pg, perm)))&#123;</span><br><span class="line">		<span class="keyword">if</span> (r != -E_IPC_NOT_RECV) panic(<span class="string">&quot;ipc_send error: %e&quot;</span>, r);</span><br><span class="line">		sys_yield();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">ipc_recv(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">// panic(&quot;ipc_recv not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">if</span> (pg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		pg = (<span class="keyword">void</span> *)UTOP;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> r = sys_ipc_recv(pg);</span><br><span class="line">	<span class="keyword">int</span> fromenv, perm;</span><br><span class="line">	<span class="keyword">if</span> (r) &#123;</span><br><span class="line">		fromenv = <span class="number">0</span>;</span><br><span class="line">		perm = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fromenv = thisenv-&gt;env_ipc_from;</span><br><span class="line">		perm = thisenv-&gt;env_ipc_perm;</span><br><span class="line">		r = thisenv-&gt;env_ipc_value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (from_env_store) *from_env_store = fromenv;</span><br><span class="line">	<span class="keyword">if</span> (perm_store) *perm_store = perm;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_try_send(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva, <span class="keyword">unsigned</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">// panic(&quot;sys_ipc_try_send not implemented&quot;);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r = envid2env(envid, &amp;e, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">pte_t</span> * pte;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (r) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!e-&gt;env_ipc_recving) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (srcva &lt; (<span class="keyword">void</span> *)UTOP) &#123;</span><br><span class="line">		<span class="keyword">if</span> (PGOFF(srcva)) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">		pp = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pte);</span><br><span class="line">		<span class="keyword">if</span> (!pp) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((perm &amp; *pte) != perm) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; !(*pte &amp; PTE_W)) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (e-&gt;env_ipc_dstva &lt; (<span class="keyword">void</span>*) UTOP) &#123;</span><br><span class="line">			r = page_insert(e-&gt;env_pgdir, pp, e-&gt;env_ipc_dstva, perm);</span><br><span class="line">			<span class="keyword">if</span> (r) &#123;</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">			&#125;</span><br><span class="line">			e-&gt;env_ipc_perm = perm;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">	e-&gt;env_ipc_value = value;</span><br><span class="line">	e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">	e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_recv(<span class="keyword">void</span> *dstva)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">// panic(&quot;sys_ipc_recv not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dstva &lt; (<span class="keyword">void</span> *)UTOP) &#123;</span><br><span class="line">		<span class="keyword">if</span> (PGOFF(dstva)) &#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	curenv-&gt;env_ipc_recving = <span class="literal">true</span>;</span><br><span class="line">	curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">	curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	curenv-&gt;env_ipc_from = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	sched_yield();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用  <code>user/pingpong</code> and <code>user/primes</code> 函数测试IPC机制。 <code>user/primes</code> 将为每个素数生成一个新的环境，直到 JOS 用完环境。您可能会发现阅读user/primes.c 来了解后台的 forking 和 IPC 会很有趣。</p>
<h4 id="Challenge-7"><a href="#Challenge-7" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>为什么 ipc_send 必须循环？更改系统调用接口，使其不必这样做。确保您可以处理多个试图同时发送到一个环境的环境。</p>
<h4 id="Challenge-8"><a href="#Challenge-8" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>质数筛只是在大量并发程序之间传递消息的一种巧妙用法。 </p>
<p>Read C. A. R. Hoare, ``Communicating Sequential Processes,’’ <em>Communications of the ACM</em> 21(8) (August 1978), 666-667, and implement the matrix multiplication example.</p>
<h4 id="Challenge-9"><a href="#Challenge-9" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>One of the most impressive examples of the power of message passing is Doug McIlroy’s power series calculator, described in <a href="https://swtch.com/~rsc/thread/squint.pdf">M. Douglas McIlroy, ``Squinting at Power Series,’’ <em>Software–Practice and Experience</em>, 20(7) (July 1990), 661-683</a>. Implement his power series calculator and compute the power series for <em>sin</em>(<em>x</em>+<em>x</em>^3).</p>
<h4 id="Challenge-10"><a href="#Challenge-10" class="headerlink" title="Challenge!"></a>Challenge!</h4><p>Make JOS’s IPC mechanism more efficient by applying some of the techniques from Liedtke’s paper, <a href="http://dl.acm.org/citation.cfm?id=168633">Improving IPC by Kernel Design</a>, or any other tricks you may think of. Feel free to modify the kernel’s system call API for this purpose, as long as your code is backwards compatible with what our grading scripts expect.</p>
]]></content>
  </entry>
</search>
