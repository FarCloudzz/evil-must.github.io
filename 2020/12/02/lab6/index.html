<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="明日边缘" type="application/atom+xml" />






<meta name="description" content="Introduction本 Lab 是你可以自己进行的最后一个项目。 现在你有了一个文件系统，任何一个有自尊的操作系统都不应该没有网络堆栈。在这个 Lab 中，你要写一个网络接口卡的驱动程序。该卡将基于 Intel 82540EM 芯片，也称为 E1000。 然而，网卡驱动程序不足以让你的操作系统连接到互联网上。在新的 lab 6 代码中，我们为您提供了一个网络堆栈和一个网络服务器。与以前的实验一">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab 6: 网络驱动">
<meta property="og:url" content="http://evil-must.github.io/2020/12/02/lab6/index.html">
<meta property="og:site_name" content="明日边缘">
<meta property="og:description" content="Introduction本 Lab 是你可以自己进行的最后一个项目。 现在你有了一个文件系统，任何一个有自尊的操作系统都不应该没有网络堆栈。在这个 Lab 中，你要写一个网络接口卡的驱动程序。该卡将基于 Intel 82540EM 芯片，也称为 E1000。 然而，网卡驱动程序不足以让你的操作系统连接到互联网上。在新的 lab 6 代码中，我们为您提供了一个网络堆栈和一个网络服务器。与以前的实验一">
<meta property="og:locale">
<meta property="og:image" content="c:/Users/dier/Pictures/ns.png">
<meta property="article:published_time" content="2020-12-02T03:40:12.000Z">
<meta property="article:modified_time" content="2020-12-02T06:05:56.695Z">
<meta property="article:author" content="别云">
<meta property="article:tag" content="code, game">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/dier/Pictures/ns.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://evil-must.github.io/2020/12/02/lab6/"/>





  <title>Lab 6: 网络驱动 | 明日边缘</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6ed4c7d747139160a38d3f510c1cf801";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 5.1.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">明日边缘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">唯有生命中的黄金岁月一去就不再来</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/home/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-留言板">
          <a href="/contact/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            留言板
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://evil-must.github.io/2020/12/02/lab6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="明日边缘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Lab 6: 网络驱动</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-02T11:40:12+08:00">
                2020-12-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  41
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>本 Lab 是你可以自己进行的最后一个项目。</p>
<p>现在你有了一个文件系统，任何一个有自尊的操作系统都不应该没有网络堆栈。在这个 Lab 中，你要写一个网络接口卡的驱动程序。该卡将基于 Intel 82540EM 芯片，也称为 E1000。</p>
<p>然而，网卡驱动程序不足以让你的操作系统连接到互联网上。在新的 lab 6 代码中，我们为您提供了一个网络堆栈和一个网络服务器。与以前的实验一样，使用 git 获取这个实验的代码，合并到您自己的代码中，并研究新 net/ 目录中的内容，以及 kern/ 中的新文件。</p>
<p>除了编写驱动程序外，您还需要创建一个系统调用接口，以便访问您的驱动程序。通过完成一个 web 服务器，您还可以将所有内容绑定在一起。使用新的 web 服务器，您将能够从文件系统中提供文件。</p>
<a id="more"></a>

<p>大部分内核设备驱动程序代码都必须从头开始编写。这个 Lab 提供的指导比以前的实验少得多：没有骨架文件，没有用石头写的系统调用接口，许多设计决策都由您来决定。因此，我们建议你在开始任何单独的练习之前，先阅读整个作业摘要。许多学生发现这个实验比以前的实验更难，所以请相应地安排你的时间。</p>
<h2 id="QEMU’s-virtual-network"><a href="#QEMU’s-virtual-network" class="headerlink" title="QEMU’s virtual network"></a>QEMU’s virtual network</h2><p>我们将使用 QEMU 的用户模式网络堆栈，因为它不需要管理特权来运行。QEMU 的文档在这里有更多关于用户网的信息。我们更新了 makefile 以启用 QEMU 的用户模式网络堆栈和虚拟 E1000 网卡。</p>
<p>默认情况下，QEMU 提供一个运行在 ip 10.0.2.2 上的虚拟路由器，并将为 JOS 分配 IP 地址 10.0.2.15。为了简单起见，我们将这些默认值硬编码到 net/ns.h 中的网络服务器中。</p>
<p>虽然 QEMU 的虚拟网络允许 JO S任意连接到 Internet，但 JOS 的 10.0.2.15 地址在 QEMU 内部运行的虚拟网络之外没有任何意义（也就是说，QEMU 充当 NAT），因此我们不能直接连接到运行在 JOS 内部的服务器，即使是从运行 QEMU 的主机。为了解决这个问题，我们将 QEMU 配置为在主机上的某个端口上运行一个服务器，该服务器只需连接到 JOS 中的某个端口，并在真实主机和虚拟网络之间来回传输数据。</p>
<p>您将在端口 7（echo）和端口 80（http）上运行 JOS 服务器。为了避免在共享的 Athena 机器上发生冲突，makefile 根据用户 ID 为这些机器生成转发端口。要了解 QEMU 要转发到开发主机上的哪个端口，请运行 make which-ports。为了方便起见，makefile 还提供 make nc-7 和 make nc-80，允许您直接与终端中这些端口上运行的服务器交互。（这些目标只连接到正在运行的 QEMU 实例；必须单独启动 QEMU 本身。）</p>
<h3 id="Packet-Inspection"><a href="#Packet-Inspection" class="headerlink" title="Packet Inspection"></a>Packet Inspection</h3><p>makefile 还配置 QEMU 的网络堆栈，以记录所有传入和传出的数据包 qemu.pcap 文件在你的 Lab 目录里。</p>
<p>要获取捕获数据包的 hex/ASCII 转储，请使用 tcpdump，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -XXnr qemu.pcap</span><br></pre></td></tr></table></figure>

<p>或者，可以使用 Wireshark 以图形方式检查 pcap 文件。Wireshark 还知道如何解码和检查数百个网络协议。</p>
<h3 id="Debugging-the-E1000"><a href="#Debugging-the-E1000" class="headerlink" title="Debugging the E1000"></a>Debugging the E1000</h3><p>我们很幸运能够使用仿真硬件。由于 E1000 是在软件中运行的，因此模拟的 E1000 可以以用户可读的格式向我们报告其内部状态和遇到的任何问题。通常情况下，这样的奢华对于一个用裸金属编写的驱动程序开发人员来说是很难获得的。</p>
<p>E1000 可以产生大量调试输出，因此必须启用特定的日志记录通道。您可能会发现一些有用的渠道是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flag		Meaning</span><br><span class="line">tx			Log packet transmit operations</span><br><span class="line">txerr		Log transmit ring errors</span><br><span class="line">rx			Log changes to RCTL</span><br><span class="line">rxfilter	Log filtering of incoming packets</span><br><span class="line">rxerr		Log receive ring errors</span><br><span class="line">unknown		Log reads <span class="keyword">and</span> writes of unknown registers</span><br><span class="line">eeprom		Log reads from the EEPROM</span><br><span class="line">interrupt	Log interrupts <span class="keyword">and</span> changes to interrupt </span><br><span class="line">											registers.</span><br></pre></td></tr></table></figure>

<p>例如,，要启用 “tx” 和 “txerr” 日志记录，请使用 make E1000_DEBUG=tx，txerr…</p>
<blockquote>
<p>注意：E1000_DEBUG 标志仅在 QEMU 的 6.828 版本中有效。</p>
</blockquote>
<p>您可以进一步使用软件仿真硬件进行调试。如果您曾经被卡住，并且不明白为什么 E1000 没有按照您预期的方式响应，那么可以查看 hw/net/E1000.c 中 QEMU 的 E1000 实现。</p>
<h2 id="The-Network-Server"><a href="#The-Network-Server" class="headerlink" title="The Network Server"></a>The Network Server</h2><p>从头开始编写网络堆栈是一项艰巨的工作。相反，我们将使用 lwIP，一个开源的轻量级 TCP/IP 协议套件，其中包括一个网络堆栈。你可以在这里找到更多关于 lwIP的信息。在这个任务中，就我们而言，lwIP 是一个实现 BSD 套接字接口的黑盒，它有一个分组输入端口和一个分组输出端口。</p>
<p>网络服务器实际上是四种环境的组合：</p>
<ul>
<li>核心网络服务器环境（包括socket call dispatcher和lwIP）</li>
<li>输入环境</li>
<li>输出环境</li>
<li>定时器环境</li>
</ul>
<p>下图显示了不同的环境及其关系。该图显示了包括设备驱动程序在内的整个系统，稍后将介绍。在这个实验中，你将实现用绿色突出显示的部分。</p>
<p><img src="C:\Users\dier\Pictures\ns.png" alt="ns"></p>
<h3 id="The-Core-Network-Server-Environment"><a href="#The-Core-Network-Server-Environment" class="headerlink" title="The Core Network Server Environment"></a>The Core Network Server Environment</h3><p>核心网络服务器环境由 socket 调用调度器和 lwIP 本身组成。socket 调用调度器的工作方式与文件服务器完全相同。用户环境使用 stubs（可以在 lib/nsipc.c 中找到）向核心网络环境发送 IPC 消息。如果你看 lib/nsipc.c，你会发现我们找到核心网络服务器的方式和找到文件服务器的方式是一样的：i386_init 用 NS_TYPE_NS 创建了 NS 环境，所以我们扫描 env，寻找这个特殊的环境类型。对于每个用户环境 IPC，网络服务器中的调度器代表用户调用 lwIP 提供的相应 BSD 套接字接口函数。</p>
<p>常规用户环境不直接使用 nsipc_*  调用。相反，它们使用 lib/sockets.c 中的函数，该函数提供了一个基于文件描述符的 sockets API。因此，用户环境通过文件描述符引用套接字，就像它们在磁盘文件中引用的那样。许多操作（connect、accept等）都是特定于套接字的，但是读、写和关闭都要经过 lib/fd.c 中的普通文件描述符设备调度代码。就像文件服务器为所有打开的文件维护内部唯一 ID 一样，lwIP 也为所有打开的套接字生成唯一 ID。在文件服务器和网络服务器中，我们使用struct Fd 中存储的信息将每个环境的文件描述符映射到这些唯一的 ID 空间。</p>
<p>尽管看起来文件服务器和网络服务器的 IPC 调度器的行为是相同的，但有一个关键的区别。像 accept 和 recv 这样的 BSD 套接字调用可以无限期地阻塞。如果调度程序让 lwIP 执行这些阻塞调用中的一个，那么调度程序也将阻塞，并且整个系统一次只能有一个未完成的网络调用。由于这是不可接受的，网络服务器使用用户级线程来避免阻塞整个服务器环境。对于每个传入的 IPC 消息，调度器创建一个线程并在新创建的线程中处理请求。如果线程阻塞，则只有该线程处于休眠状态，而其他线程继续运行。</p>
<p>除了核心网络环境外，还有三个辅助环境。除了接受来自用户应用程序的消息外，核心网络环境的调度器还接受来自输入和计时器环境的消息。</p>
<h3 id="The-Output-Environment"><a href="#The-Output-Environment" class="headerlink" title="The Output Environment"></a>The Output Environment</h3><p>当为用户环境套接字调用提供服务时，lwIP 将生成数据包供网卡传输。LwIP 将使用 NSREQ_OUTPUT IPC 消息将要传输的每个数据包发送到输出助手环境，并将数据包附加在 IPC 消息的页参数中。输出环境负责接受这些消息，并通过您即将创建的系统调用接口将数据包转发到设备驱动程序。</p>
<h3 id="The-Input-Environment"><a href="#The-Input-Environment" class="headerlink" title="The Input Environment"></a>The Input Environment</h3><p>网卡接收到的数据包需要注入 lwIP。对于设备驱动程序接收到的每个数据包，输入环境将数据包从内核空间中拉出（使用您将实现的内核系统调用），并使用NSREQ_INPUT IPC 消息将数据包发送到核心服务器环境。</p>
<p>数据包输入功能与核心网络环境分离，因为 JOS 使得同时接受 IPC 消息和轮询或等待来自设备驱动程序的数据包变得很困难。我们在 JOS 中没有 select 系统调用，它允许环境监视多个输入源，以确定哪些输入可以被处理。</p>
<p>如果您看一下 net/input.c 和 net/output.c，就会发现这两个都需要实现。这主要是因为实现依赖于您的系统调用接口。在实现驱动程序和系统调用接口之后，您将为两个 helper 环境编写代码。</p>
<h3 id="The-Timer-Environment"><a href="#The-Timer-Environment" class="headerlink" title="The Timer Environment"></a>The Timer Environment</h3><p>计时器环境定期向核心网络服务器发送 NSREQ_TIMER 类型的消息，通知它计时器已过期。来自这个线程的计时器消息被 lwIP 用来实现各种网络超时。</p>
<h1 id="Part-A-Initialization-and-transmitting-packets"><a href="#Part-A-Initialization-and-transmitting-packets" class="headerlink" title="Part A: Initialization and transmitting packets"></a>Part A: Initialization and transmitting packets</h1><p>你的内核没有时间的概念，所以我们需要添加它。目前有一个时钟中断是由硬件每 10 毫秒产生一次。在每一个时钟中断时，我们可以增加一个变量来表示时间提前了 10 毫秒。这是在 kern/time.c 中实现的，但尚未完全集成到内核中。</p>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1."></a>Exercise 1.</h4><p>为 kern/trap.c 中的每个时钟中断添加对 time_tick 的调用。实现 sys_time_msec 并将其添加到 kern/syscall.c 中的 syscall 中，以便用户空间可以访问时间。</p>
<p>使用 make INIT_CFLAGS=-DTEST_NO_NS run-testtime 来测试时间代码。您应该可以看到环境在 1 秒的间隔内从 5 开始倒计时。”-DTEST_NO_NS” ”禁用启动网络服务器环境，因为它将在 Lab 的这个点死机。</p>
<h2 id="1-The-Network-Interface-Card"><a href="#1-The-Network-Interface-Card" class="headerlink" title="1. The Network Interface Card"></a>1. The Network Interface Card</h2><p>编写驱动程序需要深入了解硬件和提供给软件的接口。实验文本将提供有关如何与 E1000 接口的高级概述，但在编写驱动程序时，您需要充分利用 Intel 的手册。</p>
<h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2."></a>Exercise 2.</h4><p>浏览 Intel 的 E1000 软件开发人员手册。本手册涵盖了几个密切相关的以太网控制器。QEMU 模仿 82540EM。</p>
<p>你现在应该浏览一下第二章来了解一下这个设备。要编写驱动程序，您需要熟悉第 3 章和第 14 章，以及 4.1（尽管不是 4.1 小节）。你还需要参考第 13 章。其他章节主要介绍 E1000 的组件，您的驱动器不必与这些组件交互。现在不必担心细节；只需了解一下文档的结构，这样以后就可以找到东西了。</p>
<p>在阅读本手册时，请记住，E1000 是一款具有许多高级功能的精密设备。一个正常工作的 E1000 驱动程序只需要 NIC 提供的功能和接口的一小部分。仔细考虑与卡连接的最简单方法。我们强烈建议您在使用高级功能之前先让一个基本的驱动程序工作。</p>
<h3 id="1-1-PCI-Interface"><a href="#1-1-PCI-Interface" class="headerlink" title="1.1 PCI Interface"></a>1.1 PCI Interface</h3><p>E1000 是 PCI 设备，这意味着它可以插入主板上的 PCI 总线。PCI 总线有地址、数据和中断线，允许 CPU 与 PCI 设备通信，PCI 设备读写内存。PCI 设备在使用之前需要被发现和初始化。发现是在 PCI 总线上寻找连接设备的过程。初始化是分配 I/O 和内存空间以及协商 IRQ 线以供设备使用的过程。</p>
<p>我们在 kern/pci.c 中为您提供了 PCI 代码。为了在引导期间执行 PCI 初始化，PCI 代码遍历 PCI 总线寻找设备。当它找到一个设备时，它会读取它的供应商 ID 和设备 ID，并使用这两个值作为一个键来搜索 pci 连接的供应商数组。该数组由 struct pci_driver 项组成，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> key1, key2;</span><br><span class="line">    <span class="keyword">int</span> (*attachfn) (struct pci_func *pcif);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果发现的设备的供应商 ID 和设备 ID 与阵列中的某个条目匹配，PCI 代码将调用该条目的 attachfn 来执行设备初始化。（设备也可以通过类来标识，这是 kern/pci.c 中另一个驱动程序表的用途。）</p>
<p>向 attach 函数传递一个 PCI 函数进行初始化。PCI 卡可以公开多个功能，但 E1000 只公开一个功能。下面是我们如何在 JOS 中表示 PCI 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_func</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_bus</span> *<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> dev;</span><br><span class="line">    <span class="keyword">uint32_t</span> func;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> dev_id;</span><br><span class="line">    <span class="keyword">uint32_t</span> dev_class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> reg_base[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_size[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> irq_line;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述结构反映了开发人员手册第 4.1 节表 4-1 中的一些条目。struct pci_func 的最后三个条目对我们特别感兴趣，因为它们记录了设备的协商内存、I/O 和中断源。寄存器基址和寄存器大小数组包含多达六个基址寄存器或 BARs 的信息。reg_base 存储内存映射 I/O 区域（或 I/O 端口资源的基本 I/O 端口）的基本内存地址，reg_size 包含来自 reg_base 的相应基本值的大小（以字节为单位）或 I/O 端口数，irq_line 包含分配给设备的中断 IRQ 行。表 4-2 后半部分给出了 E1000 条的具体含义。</p>
<p>调用设备的附加功能时，设备已找到但尚未启用。这意味着 PCI 代码还没有确定分配给设备的资源，例如地址空间和 IRQ 行，因此，struct pci_func 结构的最后三个元素尚未填充。attach 函数应该调用 pci_chfunc_enable，它将启用设备、协商这些资源并填充结构 pci_func。</p>
<h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3."></a>Exercise 3.</h4><p>实现 attach 函数以初始化 E1000。在 kern/pci.c 中向 pci_attach_vendor 数组添加一个条目，以便在找到匹配的 pc i设备时触发您的函数（确保将它放在标记表末尾的 {0，0，0} 项之前）。您可以在第 5.2 节中找到 QEMU 模拟的 82540EM 的供应商 ID 和设备 ID。当 JOS 在引导时扫描 PCI 总线时，您还应该看到这些列表。</p>
<p>现在，只需通过 pci_func_enable 启用 E1000 设备。我们将在整个实验室中添加更多的初始化。</p>
<p>我们已经为您提供了 kern/e1000.c 和 kern/e1000.h 文件，这样您就不需要破坏构建系统了。它们当前为空；您需要在本练习中填写它们。您可能还需要在内核的其他位置包含 e1000.h 文件。</p>
<p>当您启动内核时，您应该看到它显示 E1000 卡的 PCI 功能已启用。您的代码现在应该通过 make grade 的 pci 连接测试。</p>
<h3 id="1-2-Memory-mapped-I-O"><a href="#1-2-Memory-mapped-I-O" class="headerlink" title="1.2 Memory-mapped I/O"></a>1.2 Memory-mapped I/O</h3><p>软件通过内存映射 I/O（MMIO）与 E1000 通信。在 JOS 中你已经见过两次了：CGA 控制台和 LAPIC 都是通过对“内存”进行读写来控制和查询的设备。但是这些读写操作不会进入 DRAM；它们直接进入这些设备。</p>
<p>pci_func_enable 与 E1000协商 MMIO 区域，并将其基数和大小存储在 BAR 0 中（也就是说，reg_base[0] 和 reg_size[0]）。这是分配给设备的物理内存地址范围，这意味着您必须通过虚拟地址来访问它。由于 MMIO 区域被分配了非常高的物理地址（通常超过 3GB），所以由于 JOS 的 256MB 限制，您不能使用 KADDR 来访问它。因此，您必须创建一个新的内存映射。我们将使用 MMIOBASE 上面的区域（您的来自 Lab 4 的 mmio_map_region 将确保我们不会覆盖 LAPIC 使用的映射）。由于 PCI 设备初始化发生在 JOS 创建用户环境之前，所以您可以在 kern_pgdir 中创建映射，并且该映射始终可用。</p>
<h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4."></a>Exercise 4.</h4><p>在 attach 函数中，通过调用 mmio_map_region（您在 Lab 4 中编写的支持 LAPIC内存映射）为 E1000 的 BAR 0 创建一个虚拟内存映射。</p>
<p>您需要将这个映射的位置记录在一个变量中，以便以后可以访问刚刚映射的寄存器。查看 kern/lapic.c 中的 lapic 变量，以了解一种方法。如果你确实使用了指向设备寄存器映射的指针，一定要声明它是 volatile；否则，允许编译器缓存值并重新排序对该内存的访问。</p>
<p>要测试映射，请尝试打印设备状态寄存器（第 13.4.2 节）。这是一个 4 字节寄存器，从寄存器空间的字节 8 开始。您应该得到 0x80080783，这表示全双工链路的速度是 1000MB/s。</p>
<p>提示：你需要很多常量，比如寄存器的位置和位掩码的值。试图从开发人员手册中复制这些内容是很容易出错的，错误可能会导致痛苦的调试会话。我们建议使用 QEMU 的 e1000_hw.h 头作为指导。我们不建议一字不差地复制它，因为它定义的内容远远超出了您实际需要的范围，并且可能无法按照您需要的方式定义内容，但这是一个很好的起点。</p>
<h3 id="1-3-DMA"><a href="#1-3-DMA" class="headerlink" title="1.3 DMA"></a>1.3 DMA</h3><p>您可以想象通过写入和读取 E1000 的寄存器来发送和接收数据包，但这会很慢，并且需要 E1000 在内部缓冲包数据。您可以想象通过写入和读取 E1000 的寄存器来发送和接收数据包，但这会很慢，并且需要 E1000 在内部缓冲包数据。驱动程序负责为发送和接收队列分配内存，设置 DMA 描述符，并为 E1000 配置这些队列的位置，但之后的一切都是异步的。为了发送分组，驱动程序将其复制到发送队列中的下一个 DMA 描述符中，并通知 E1000 另一个分组可用；当有时间发送数据包时，E1000 将从描述符中复制数据。同样，当 E1000 接收到一个数据包时，它将其复制到接收队列中的下一个 DMA 描述符中，驱动程序可以在下一个机会从中读取。</p>
<p>接收队列和传输队列在高层非常相似。两者都由一系列描述词组成。虽然这些描述符的确切结构各不相同，但每个描述符都包含一些标志和包含数据包数据的缓冲区的物理地址（卡要发送的数据包数据，或操作系统为卡分配的缓冲区，以将接收到的数据包写入其中）。</p>
<p>队列被实现为圆形数组，这意味着当卡或驱动程序到达数组的末尾时，它会返回到数组的开头。它们都有一个头指针和一个尾指针，队列的内容是这两个指针之间的描述符。硬件总是从头部使用描述符并移动头部指针，而驱动程序总是向尾部添加描述符并移动尾部指针。传输队列中的描述符表示等待发送的包（因此，在稳定状态下，传输队列为空）。对于接收队列，队列中的描述符是卡可以接收数据包的空闲描述符（因此，在稳定状态下，接收队列由所有可用的接收描述符组成）。在不混淆 E1000 的情况下正确更新尾寄存器是很困难的；小心！</p>
<p>指向这些数组的指针以及描述符中数据包缓冲区的地址都必须是物理地址，因为硬件直接执行 DMA 往返于物理 RAM 而不经过 MMU。</p>
<h2 id="2-Transmitting-Packets"><a href="#2-Transmitting-Packets" class="headerlink" title="2. Transmitting Packets"></a>2. Transmitting Packets</h2><p>E1000 的发送和接收功能基本上是相互独立的，因此我们可以一次处理一个。我们将首先攻击发送数据包，因为如果不发送 “I’m here!” 就无法测试接收先打包。</p>
<p>首先，您必须按照 14.5 节中描述的步骤初始化卡以进行传输（您不必担心子部分）。传输初始化的第一步是设置传输队列。队列的精确结构在第 3.4 节中描述，描述符的结构在第 3.3.3 节中描述。我们不会使用 E1000 的 TCP 卸载功能，所以您可以关注 “legacy transmit descriptor format”。你现在应该阅读这些章节并熟悉这些结构。</p>
<h3 id="2-1-C-Structures"><a href="#2-1-C-Structures" class="headerlink" title="2.1 C Structures"></a>2.1 C Structures</h3><p>您将发现使用 C 结构来描述 E1000 的结构非常方便。正如您在 struct Trapframe 等结构中看到的，C 结构允许您精确地在内存中布局数据。C 可以在字段之间插入填充，但是 E1000 的结构是这样布置的，这样就不会有问题了。如果确实遇到字段对齐问题，请查看 GCC 的 “packed” 属性。</p>
<p>以本手册表 3-8 中给出的旧传输描述符为例，并在此复制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">63</span>            <span class="number">48</span> <span class="number">47</span>   <span class="number">40</span> <span class="number">39</span>   <span class="number">32</span> <span class="number">31</span>   <span class="number">24</span> <span class="number">23</span>   <span class="number">16</span> <span class="number">15</span>     <span class="number">0</span></span><br><span class="line">  +-----------------------------------------------------+</span><br><span class="line">  |                         Buffer address                   |</span><br><span class="line">  +---------------+-------+-------+-------+-------+-----+</span><br><span class="line">  |    Special   |  CSS  | Status|  Cmd  | CSO | Length  |</span><br><span class="line">  +---------------+-------+-------+-------+-------+-----+</span><br></pre></td></tr></table></figure>

<p>结构的第一个字节从右上角开始，因此要将其转换为 C 结构，请从右到左、从上到下读取。如果您正确地斜视它，您将看到所有字段甚至可以很好地适应标准大小的类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uint64_t</span> addr;</span><br><span class="line">	<span class="keyword">uint16_t</span> length;</span><br><span class="line">	<span class="keyword">uint8_t</span> cso;</span><br><span class="line">	<span class="keyword">uint8_t</span> cmd;</span><br><span class="line">	<span class="keyword">uint8_t</span> status;</span><br><span class="line">	<span class="keyword">uint8_t</span> css;</span><br><span class="line">	<span class="keyword">uint16_t</span> special;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>驱动程序必须为传输描述符数组和传输描述符指向的数据包缓冲区预留内存。有几种方法可以做到这一点，从动态分配页面到简单地在全局变量中声明页面。无论您选择什么，请记住 E1000 直接访问物理内存，这意味着它访问的任何缓冲区在物理内存中都必须是连续的。</p>
<p>还有多种方法可以处理数据包缓冲区。我们建议从最简单的开始，就是在驱动程序初始化期间为每个描述符预留一个包缓冲区的空间，并简单地将包数据复制到这些预先分配的缓冲区中。以太网数据包的最大大小是 1518 字节，这限制了这些缓冲区的大小。更复杂的驱动程序可以动态地分配数据包缓冲区（例如，在网络使用率较低时减少内存开销），甚至可以传递用户空间直接提供的缓冲区（一种称为“零拷贝”的技术），但最好从简单开始。</p>
<h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5."></a>Exercise 5.</h4><p>执行第 14.5 节（但不包括其小节）中描述的初始化步骤。使用第 13 节作为初始化过程引用的寄存器的参考，使用第 3.3.3 节和第 3.4 节作为传输描述符和传输描述符数组的参考。</p>
<p>请注意传输描述符阵列的对齐要求和此阵列长度的限制。由于 TDLEN 必须是 128 字节对齐的，并且每个传输描述符是 16 字节，因此传输描述符数组将需要 8 个传输描述符中的若干个。但是，不要使用超过 64 个描述符，否则我们的测试将无法测试传输环溢出。</p>
<p>对于 TCTL.COLD，可以采用全双工操作。对于 TIPG，参考 IEEE 802.3 标准 IPG 第 13.4.34 节表 13-77 中所述的默认值（不要使用 14.5 节表中的值）。</p>
<p>尝试运行 mak E1000_DEBUG=TXERR，TX qemu。如果您正在使用课程 qemu，当您设置 TDT 寄存器时，应该会看到一条 “e1000:tx disabled” 消息（因为这发生在设置之前 TCEN.CN)没有更多的 “e1000” 信息。</p>
<p>既然传输已经初始化，您就必须编写代码来传输数据包，并通过系统调用使其可以访问用户空间。要传输数据包，必须将其添加到传输队列的尾部，这意味着将数据包数据复制到下一个数据包缓冲区，然后更新 TDT（传输描述符尾部）寄存器，以通知卡在传输队列中还有另一个包。（请注意，TDT 是传输描述符数组的索引，而不是字节偏移量；文档对此不是很清楚。）</p>
<p>然而，传输队列只有这么大。如果卡落后于传输数据包，并且传输队列已满，会发生什么情况？为了检测到这种情况，您需要 E1000 提供一些反馈。不幸的是，不能只使用 TDH（传输描述符头）寄存器；文档明确指出从软件中读取此寄存器是不可靠的。但是，如果您在传输描述符的命令字段中设置 RS 位，那么当卡在该描述符中传输了包时，该卡将在描述符的状态字段中设置 DD 位。如果设置了描述符的 DD 位，您就知道回收该描述符并使用它来传输另一个数据包是安全的。</p>
<p>如果用户调用您的传输系统调用，但下一个描述符的 DD 位没有设置，这表示传输队列已满，该怎么办？你得决定在这种情况下该怎么办。你可以把包裹扔了。网络协议对此是有弹性的，但是如果丢弃大量的数据包，协议可能无法恢复。相反，您可以告诉用户环境，它必须重试，就像您对 sys_ipc_try_send 所做的那样。这样做的好处是将生成数据的环境向后推。</p>
<h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6."></a>Exercise 6.</h4><p>编写一个函数，通过检查下一个描述符是否空闲，将数据包数据复制到下一个描述符中，并更新 TDT 来传输数据包。确保处理的传输队列已满。</p>
<p>现在是测试包传输代码的好时机。通过直接从内核调用传输函数，尝试只传输一些数据包。您不必创建符合任何特定网络协议的数据包来进行测试。运行 make E1000_DEBUG=TXERR，TX qemu 来运行测试。当你传输数据包时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e1000: index <span class="number">0</span>: <span class="number">0x271f00</span> : <span class="number">9000002</span>a <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>每行给出传输数组中的索引、该传输描述符的缓冲区地址、cmd/CSO/length 字段和 special/CSS/status 字段。如果 QEMU 没有从传输描述符中打印出您期望的值，请检查您填写的描述符是否正确，以及 TDBAL 和 TDBAH 的配置是否正确。如果您收到 “e1000:TDH wrapparound@0，TDT x，TDLEN y” 消息，这意味着 e1000在传输队列中一路运行而没有停止（如果 QEMU 没有检查这个，它将进入一个无限循环），这可能意味着您没有正确地操作 TDT。</p>
<p>一旦 QEMU 运行，就可以运行 tcpdump-XXnr qemu.pcap 文件以查看您传输的数据包。如果您看到来自 QEMU 的预期 “e1000:index” 消息，但您的数据包捕获是空的，请仔细检查您是否在传输描述符中填写了所有必需的字段和位（e1000 可能遍历了您的传输描述符，但认为它不必发送任何内容）。</p>
<h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7."></a>Exercise 7.</h4><p>添加一个允许从用户空间传输数据包的系统调用。具体界面由您决定。不要忘记检查从用户空间传递到内核的任何指针。</p>
<h2 id="3-Transmitting-Packets-Network-Server"><a href="#3-Transmitting-Packets-Network-Server" class="headerlink" title="3. Transmitting Packets: Network Server"></a>3. Transmitting Packets: Network Server</h2><p>现在你有了一个系统调用接口到你的设备驱动程序的传输端，是时候发送数据包了。输出辅助环境的目标是在循环中执行以下操作：接受来自核心网络服务器的NSREQ_OUTPUT IPC 消息，并使用上面添加的系统调用将这些 IPC 消息附带的数据包发送到网络设备驱动程序。NSREQ_OUTPUT IPC 由 net/lwip/jos/jif/jif.c 中的low_level_output 函数发送，该函数将 lwip 堆栈粘到 jos 的网络系统上。每个 IPC将包括一个由 union Nsipc 组成的页面，其中的数据包位于其 struct jif_pkt pkt 字段中（参见 inc/ns.h）。struct jif_pkt 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jif_pkt</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> jp_len;</span><br><span class="line">    <span class="keyword">char</span> jp_data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>jp_len 表示数据包的长度。IPC 页上的所有后续字节都专用于数据包内容。在结构末尾使用零长度数组（如 jp_data）是一种常见的 C 技巧（有人会说讨厌），用于表示没有预先确定长度的缓冲区。由于 C 不做数组边界检查，只要确保结构后面有足够的未使用内存，就可以像使用任何大小的数组一样使用 jp_data。</p>
<p>当设备驱动程序的传输队列中没有更多空间时，请注意设备驱动程序、输出环境和核心网络服务器之间的交互。核心网络服务器使用 IPC 向输出环境发送数据包。如果由于驱动程序没有更多的缓冲区空间用于新的数据包而由于发送数据包系统调用而暂停输出环境，则核心网络服务器将阻塞等待输出服务器接受 IPC 调用。</p>
<h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8."></a>Exercise 8.</h4><p>实现 <code>net/output.c</code>.</p>
<p>您可以使用 net/testoutput.c 测试输出代码，而不需要涉及整个网络服务器。尝试运行 make E1000_DEBUG=tTXERR，TX run-net_testoutput。你应该看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transmitting packet 0</span><br><span class="line">e1000: index 0: 0x271f00 : 9000009 0</span><br><span class="line">Transmitting packet 1</span><br><span class="line">e1000: index 1: 0x2724ee : 9000009 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>and  tcpdump -XXnr qemu.pcap  should output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reading from file qemu.pcap, link-type EN10MB (Ethernet)</span><br><span class="line">-5:00:00.600186 [|ether]</span><br><span class="line">	0x0000:  5061 636b 6574 2030 30            Packet.00</span><br><span class="line">-5:00:00.610080 [|ether]</span><br><span class="line">	0x0000:  5061 636b 6574 2030 31            Packet.01</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>要使用更大的数据包计数进行测试，try make E1000_DEBUG=TXERR,TX NET_CFLAGS=-DTESTOUTPUT_COUNT=100 run-net_testoutput。如果这溢出了传输环，请再次检查您是否正确地处理了 DD 状态位，并且您已经告诉硬件设置了 DD 状态位（使用 RS 命令位）。</p>
<p>您的代码应该通过 make-grade 的 testoutput 测试。</p>
<h4 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h4><p>您是如何构建传输实现的？特别是，如果传输环满了怎么办？</p>
<h1 id="Part-B-Receiving-packets-and-the-web-server"><a href="#Part-B-Receiving-packets-and-the-web-server" class="headerlink" title="Part B: Receiving packets and the web server"></a>Part B: Receiving packets and the web server</h1><h2 id="1-Receiving-Packets"><a href="#1-Receiving-Packets" class="headerlink" title="1. Receiving Packets"></a>1. Receiving Packets</h2><p>就像传输数据包一样，您必须配置 E1000 来接收数据包，并提供接收描述符队列和接收描述符。</p>
<h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9."></a>Exercise 9.</h4><p>阅读第3.2节。您可以忽略关于中断和校验和卸载的任何内容（如果您稍后决定使用这些功能，您可以返回到这些部分），并且您不必关心阈值的细节以及卡的内部缓存是如何工作的。</p>
<p>接收队列与传输队列非常相似，只是它由等待填充入站数据包的空数据包缓冲区组成。因此，当网络空闲时，传输队列是空的（因为所有的包都已发送），但是接收队列是满的（空包缓冲区）。</p>
<p>当 E1000 接收到一个数据包时，它首先检查它是否与卡上配置的过滤器匹配（例如，查看该数据包是否指向该 E1000 的 MAC 地址），如果该数据包与任何过滤器都不匹配，则忽略该数据包。否则，E1000 将尝试从接收队列的头部检索下一个接收描述符。如果 head（RDH）赶上了 tail（RDT），那么接收队列就没有空闲描述符了，因此卡会丢弃数据包。如果有空闲的接收描述符，它将数据包数据复制到描述符指向的缓冲区，设置描述符的 DD（描述符完成）和 EOP（数据包结束）状态位，并增加 RDH。</p>
<p>如果 E1000 在一个接收描述符中接收到大于包缓冲区的包，则它将从接收队列中检索所需数量的描述符，以存储包的全部内容。为了表明发生了这种情况，它将在所有这些描述符上设置 DD status 位，但只在最后一个描述符上设置 EOP status 位。您可以在驱动程序中处理这种可能性，也可以简单地将卡配置为不接受“长数据包”（也称为巨型帧），并确保接收缓冲区足够大以存储最大的标准以太网数据包（1518 字节）。</p>
<h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10."></a>Exercise 10.</h4><p>按照 14.4 节中的过程设置接收队列并配置 E1000。你不必支持“长数据包”或多播。现在，不要将卡配置为使用中断；如果您决定使用接收中断，您可以稍后更改它。另外，配置 E1000 以剥离以太网 CRC，因为 grade 脚本期望它被剥离。</p>
<p>默认情况下，该卡将过滤掉所有数据包。您必须用卡自己的 MAC 地址配置接收地址寄存器（RAL 和 RAH），以便接收发往该卡的数据包。你可以简单地硬编码 QEMU 的默认 MAC 地址 52:54:00:12:34:56（我们已经在 lwIP 中硬编码了，所以在这里做也不会让事情变得更糟）。注意字节顺序；MAC 地址是从最低顺序字节写入最高顺序字节的，因此 52:54:00:12 是 MAC 地址的低位 32 位，34:56 是高位 16 位。</p>
<p>E1000 仅支持一组特定的接收缓冲区大小（在 RCTL.B 大小第 13.4.22 节）。如果使接收包缓冲区足够大并禁用长数据包，就不必担心数据包跨越多个接收缓冲区。另外，请记住，与传输一样，接收队列和数据包缓冲区在物理内存中必须是连续的。</p>
<p>您应该使用至少 128 个接收描述符。</p>
<p>现在您可以对接收功能进行基本测试，即使不编写接收数据包的代码。运行 make E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER run-net_testinput。testinput 将传输一个 ARP（地址解析协议）公告包（使用包传输系统调用），QEMU 将自动回复该包。即使您的驱动程序还无法收到此回复，您也应该看到 “e1000:unicast match[0]：52:54:00:12:34:56” 消息，表明 e1000 已接收到一个数据包，并且与配置的接收筛选器匹配。如果您看到 “e1000:unicast mismatch:52:54:00:12:34:56” 消息，e1000 会过滤掉数据包，这意味着您可能没有正确配置 RAL 和 RAH。确保字节排序正确，并且不要忘记在 RAH 中设置 “Address Valid” 位。如果没有收到任何 “e1000” 消息，则可能没有正确启用 receive。</p>
<p>现在可以实现接收包了。要接收数据包，您的驱动程序必须跟踪它希望保存下一个接收到的数据包的描述符（提示：根据您的设计，E1000 中可能已经有一个寄存器在跟踪这个数据包）。与传输类似，文档声明 RDH 寄存器不能从软件中可靠地读取，因此为了确定数据包是否已被传递到描述符的数据包缓冲区，您必须读取描述符中的 DD 状态位。如果设置了 DD 位，您可以将数据包数据从描述符的数据包缓冲区中复制出来，然后通过更新队列的尾部索引 RDT 告诉卡描述符是空闲的。</p>
<p>如果未设置 DD 位，则没有收到任何数据包。这相当于传输队列已满时的接收端，在这种情况下您可以做一些事情。您只需返回一个“重试”错误并要求调用方重试。虽然这种方法对于完全传输队列很有效，因为这是一个暂时的条件，但是对于空的接收队列则不太合理，因为接收队列可能会在很长一段时间内保持为空。第二种方法是挂起调用环境，直到接收队列中有要处理的数据包为止。这种策略与 sys_ipc_recv 非常相似。就像 IPC 的情况一样，由于每个 CPU 只有一个内核堆栈，所以一旦离开内核，堆栈上的状态就会丢失。我们需要设置一个标志，指示环境已被接收队列下溢挂起，并记录系统调用参数。这种方法的缺点是复杂性：必须指示 E1000 生成接收中断，并且驱动程序必须处理这些中断，以便恢复阻塞的等待数据包的环境。</p>
<h4 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11."></a>Exercise 11.</h4><p>编写一个函数从 E1000 接收数据包，并通过添加系统调用将其公开给用户空间。</p>
<h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><p>如果传输队列已满或接收队列为空，则环境和驱动程序可能会花费大量的 CPU 周期进行轮询，等待描述符。E1000 在使用传输或接收描述符完成后可以生成中断，从而避免了轮询的需要。修改您的驱动程序，使处理发送和接收队列都是中断驱动的，而不是轮询。</p>
<p>请注意，一旦中断被断言，它将保持断言状态，直到驱动程序清除该中断为止。在中断处理程序中，确保在处理中断后立即清除它。如果不这样做，在从中断处理程序返回后，CPU 将再次跳回中断处理程序。除了清除 E1000 卡上的中断之外，还需要在 LAPIC 上清除中断。使用 lapic_eoi 进行此操作。</p>
<h2 id="2-Receiving-Packets-Network-Server"><a href="#2-Receiving-Packets-Network-Server" class="headerlink" title="2. Receiving Packets: Network Server"></a>2. Receiving Packets: Network Server</h2><p>在网络服务器输入环境中，您需要使用新的接收系统调用来接收数据包，并使用NSREQ_INPUT IPC 消息将它们传递到核心网络服务器环境。这些 IPC 输入消息应该有一个带有 union Nsipc 的页面，其 struct jif_pkt pkt 字段用从网络接收的包填充。</p>
<h4 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12."></a>Exercise 12.</h4><p>实现 <code>net/input.c</code>.</p>
<p>运行 <code>make E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER run-net_testinput</code>，会出现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sending ARP announcement...</span><br><span class="line">Waiting <span class="keyword">for</span> packets...</span><br><span class="line">e1000: index <span class="number">0</span>: <span class="number">0x26dea0</span> : <span class="number">900002</span>a <span class="number">0</span></span><br><span class="line">e1000: unicast match[<span class="number">0</span>]: <span class="number">52</span>:<span class="number">54</span>:<span class="number">00</span>:<span class="number">12</span>:<span class="number">34</span>:<span class="number">56</span></span><br><span class="line">input: <span class="number">0000</span>   <span class="number">5254</span> <span class="number">0012</span> <span class="number">3456</span> <span class="number">5255</span>  <span class="number">0</span>a00 <span class="number">0202</span> <span class="number">0806</span> <span class="number">0001</span></span><br><span class="line">input: <span class="number">0010</span>   <span class="number">0800</span> <span class="number">0604</span> <span class="number">0002</span> <span class="number">5255</span>  <span class="number">0</span>a00 <span class="number">0202</span> <span class="number">0</span>a00 <span class="number">0202</span></span><br><span class="line">input: <span class="number">0020</span>   <span class="number">5254</span> <span class="number">0012</span> <span class="number">3456</span> <span class="number">0</span>a00  <span class="number">020f</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">input: <span class="number">0030</span>   <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br></pre></td></tr></table></figure>

<p>以 “input:” 开头的行是 QEMU 的 ARP 回复的十六进制转储。</p>
<p>您的代码应该通过 make-grade 的 testinput 测试。请注意，如果不发送至少一个 ARP 包来通知 QEMU JOS 的 IP 地址，就无法测试数据包的接收，因此传输代码中的错误会导致测试失败。</p>
<p>为了更彻底地测试您的网络代码，我们提供了一个名为 echosrv 的守护程序，它设置了一个运行在端口 7 上的 echo 服务器，该服务器将回送通过 TCP 连接发送的任何内容。使用 make E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER run-echosrv 在一个终端中启动 echo 服务器，并在另一个终端中 make nc-7 连接到它。你输入的每一行都应该被服务器回显。每次仿真的 E1000 接收到数据包时，QEMU 应该在控制台上打印如下内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e1000: unicast match[<span class="number">0</span>]: <span class="number">52</span>:<span class="number">54</span>:<span class="number">00</span>:<span class="number">12</span>:<span class="number">34</span>:<span class="number">56</span></span><br><span class="line">e1000: index <span class="number">2</span>: <span class="number">0x26ea7c</span> : <span class="number">9000036</span> <span class="number">0</span></span><br><span class="line">e1000: index <span class="number">3</span>: <span class="number">0x26f06a</span> : <span class="number">9000039</span> <span class="number">0</span></span><br><span class="line">e1000: unicast match[<span class="number">0</span>]: <span class="number">52</span>:<span class="number">54</span>:<span class="number">00</span>:<span class="number">12</span>:<span class="number">34</span>:<span class="number">56</span></span><br></pre></td></tr></table></figure>

<p>此时，可以通过 echosrv 测试。</p>
<h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h4><p>你是如何组织你的接收实现的？特别是，如果接收队列为空，并且用户环境请求下一个传入数据包，您将怎么做？</p>
<h4 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge"></a>Challenge</h4><p>阅读开发人员手册中的 EEPROM，并编写代码将 E1000 的 MAC 地址从 EEPROM 中加载出来。目前，QEMU 的默认 MAC 地址被硬编码到接收初始化和 lwIP 中。修复初始化以使用从 EEPROM 读取的 MAC 地址，添加系统调用以将 MAC 地址传递给 lwIP，并将 lwIP 修改为从卡读取的 MAC 地址。通过配置 QEMU 使用不同的 MAC 地址来测试您的更改。</p>
<h4 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge"></a>Challenge</h4><p>将 E1000 驱动程序修改为“零拷贝”。目前，包数据必须从用户空间缓冲区复制到传输包缓冲区，并从接收包缓冲区复制回用户空间缓冲区。零拷贝驱动程序通过让用户空间和 E1000 直接共享数据包缓冲存储器来避免这种情况。有许多不同的方法可以实现这一点，包括将内核分配的结构映射到用户空间，或者将用户提供的缓冲区直接传递给 E1000。不管您的方法是什么，请注意如何重用缓冲区，以免在用户空间代码和 E1000 之间引入竞争。</p>
<h4 id="Challenge-3"><a href="#Challenge-3" class="headerlink" title="Challenge"></a>Challenge</h4><p>将零拷贝概念一直引入 lwIP。</p>
<p>一个典型的包由许多报头组成。用户在一个缓冲区中发送要传输到 lwIP 的数据。TCP 层想要添加一个 TCP 报头，IP 层需要添加一个 IP 报头，MAC 层需要添加一个以太网报头。即使一个包有许多部分，现在这些部分需要连接在一起，以便设备驱动程序可以发送最终的包。</p>
<p>E1000 的传输描述符设计非常适合于收集分散在内存中的数据包片段，比如在 lwIP 中创建的数据包片段。如果您对多个传输描述符进行排队，但只在最后一个描述符上设置 EOP 命令位，则 E1000 将从这些描述符内部连接数据包缓冲区，并且仅在连接的缓冲区到达 EOP 标记的描述符时传输连接的缓冲区。因此，各个包片段不需要在内存中连接在一起。</p>
<p>改变你的驱动程序，使之能够在不复制和修改 lwIP 的情况下发送由许多缓冲区组成的数据包，以避免像现在这样合并数据包。</p>
<h4 id="Challenge-4"><a href="#Challenge-4" class="headerlink" title="Challenge"></a>Challenge</h4><p>扩充系统调用接口以服务于多个用户环境。如果有多个网络堆栈（和多个网络服务器）在用户模式下运行，每个堆栈都有自己的IP地址，这将被证明是有用的。接收系统调用将需要决定将每个传入数据包转发到哪个环境。</p>
<p>注意，当前接口不能区分两个包之间的区别，并且如果多个环境调用包接收系统调用，则每个相应的环境将获得传入分组的子集，并且该子集可以包括未发往调用环境的分组。</p>
<p>这篇外内核论文的第 2.2 和 3 节对这个问题进行了深入的解释，并给出了在 JOS 这样的内核中解决这个问题的方法。利用这篇文章来帮助你抓住问题，很可能你不需要一个像论文中提到的那样复杂的解决方案。</p>
<h2 id="3-The-Web-Server"><a href="#3-The-Web-Server" class="headerlink" title="3. The Web Server"></a>3. The Web Server</h2><p>web 服务器以其最简单的形式将文件的内容发送到请求的客户端。我们在 user/httpd.c 中为一个非常简单的 web 服务器提供了框架代码。框架代码处理传入的连接并解析头。</p>
<h4 id="Exercise-13"><a href="#Exercise-13" class="headerlink" title="Exercise 13."></a>Exercise 13.</h4><p>web 服务器缺少处理将文件内容发送回客户端的代码。通过实现 send_file 和 send_data 来完成 web 服务器。</p>
<p>完成 web 服务器后，启动 webserver（make run-httpd-nox）并将您最喜欢的浏览器指向 <a href="http://host:port/index.html，其中">http://host:port/index.html，其中</a> host 是运行 QEMU 的计算机的名称（如果您在 athena 上运行 QEMU，请使用 hostname.mit.edu（hostname 是athena 上 hostname 命令的输出，或者 localhost（如果您在同一台计算机上运行web 浏览器和 QEMU），port 是 make which-ports为 web 服务器报告的端口号。您应该会看到一个由运行在 JOS 中的 HTTP 服务器提供服务的 web 页面。、</p>
<p>make grade 得到 105/105 。</p>
<h4 id="Challenge-5"><a href="#Challenge-5" class="headerlink" title="Challenge"></a>Challenge</h4><p>向JOS添加一个简单的聊天服务器，多个人可以连接到服务器，任何用户类型的内容都会传输给其他用户。为此，您必须找到一种方法，一次与多个套接字通信，并在同一个套接字上同时发送和接收。有多种方法可以解决这个问题。lwIP 为 recv 提供了一个 MSG_DONTWAIT 标志（请参阅 net/lwIP/api/sockets.c 中的 lwIP_recvfrom），因此您可以不断地循环所有打开的套接字，轮询它们以获取数据。请注意，虽然 recv 标志受网络服务器 IPC 的支持，但它们不能通过常规的 read 函数访问，因此需要一种方法来传递这些标志。一种更有效的方法是为每个连接启动一个或多个环境，并使用 IPC 来协调它们。方便地说，在 struct Fd 中为套接字找到的 lwIP 套接字 ID 是全局的（不是针对每个环境），因此，例如，fork 的子对象继承其父套接字。或者，环境甚至可以通过构造包含正确套接字 ID 的 Fd 发送到另一个环境的套接字。</p>
<h4 id="Question-2"><a href="#Question-2" class="headerlink" title="Question"></a>Question</h4><p>JOS的web服务器提供的web页面说明了什么？</p>
<p>你做这个实验大概花了多长时间？</p>

      
    </div>
    
    
    
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/02/lab5/" rel="next" title="Lab 5: 文件系统">
                <i class="fa fa-chevron-left"></i> Lab 5: 文件系统
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>
          <!--
          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          
          -->
          
          

  <div class="links-of-blogroll motion-element links-of-blogroll-block">
    <div class="links-of-blogroll-title">
      <!-- modify icon to fire by szw -->
      <i class="fa fa-history fa-" aria-hidden="true"></i>
      近期文章
    </div>
    <ul class="links-of-blogroll-list">
      
      
        <li class="recent_posts_li">
          <a href="/2020/12/02/lab6/" title="Lab 6: 网络驱动" target="_blank">Lab 6: 网络驱动</a>
        </li>
      
        <li class="recent_posts_li">
          <a href="/2020/12/02/lab5/" title="Lab 5: 文件系统" target="_blank">Lab 5: 文件系统</a>
        </li>
      
        <li class="recent_posts_li">
          <a href="/2020/12/02/lab4/" title="Lab 4: 抢占式多任务调度" target="_blank">Lab 4: 抢占式多任务调度</a>
        </li>
      
        <li class="recent_posts_li">
          <a href="/2020/12/02/lab3/" title="Lab 3：用户环境" target="_blank">Lab 3：用户环境</a>
        </li>
      
        <li class="recent_posts_li">
          <a href="/2020/12/02/lab2/" title="Lab 2：内存管理" target="_blank">Lab 2：内存管理</a>
        </li>
      
    </ul>
  </div>

<!--
<div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1407551413&auto=1&height=66"></iframe>
</div>
-->
          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QEMU%E2%80%99s-virtual-network"><span class="nav-text">QEMU’s virtual network</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Packet-Inspection"><span class="nav-text">Packet Inspection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Debugging-the-E1000"><span class="nav-text">Debugging the E1000</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Network-Server"><span class="nav-text">The Network Server</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Core-Network-Server-Environment"><span class="nav-text">The Core Network Server Environment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Output-Environment"><span class="nav-text">The Output Environment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Input-Environment"><span class="nav-text">The Input Environment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Timer-Environment"><span class="nav-text">The Timer Environment</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-A-Initialization-and-transmitting-packets"><span class="nav-text">Part A: Initialization and transmitting packets</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-1"><span class="nav-text">Exercise 1.</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-The-Network-Interface-Card"><span class="nav-text">1. The Network Interface Card</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-2"><span class="nav-text">Exercise 2.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-PCI-Interface"><span class="nav-text">1.1 PCI Interface</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-3"><span class="nav-text">Exercise 3.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Memory-mapped-I-O"><span class="nav-text">1.2 Memory-mapped I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-4"><span class="nav-text">Exercise 4.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-DMA"><span class="nav-text">1.3 DMA</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Transmitting-Packets"><span class="nav-text">2. Transmitting Packets</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-C-Structures"><span class="nav-text">2.1 C Structures</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-5"><span class="nav-text">Exercise 5.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-6"><span class="nav-text">Exercise 6.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-7"><span class="nav-text">Exercise 7.</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Transmitting-Packets-Network-Server"><span class="nav-text">3. Transmitting Packets: Network Server</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-8"><span class="nav-text">Exercise 8.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Question"><span class="nav-text">Question</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-B-Receiving-packets-and-the-web-server"><span class="nav-text">Part B: Receiving packets and the web server</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Receiving-Packets"><span class="nav-text">1. Receiving Packets</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-9"><span class="nav-text">Exercise 9.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-10"><span class="nav-text">Exercise 10.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-11"><span class="nav-text">Exercise 11.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Challenge"><span class="nav-text">Challenge</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Receiving-Packets-Network-Server"><span class="nav-text">2. Receiving Packets: Network Server</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-12"><span class="nav-text">Exercise 12.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Question-1"><span class="nav-text">Question</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Challenge-1"><span class="nav-text">Challenge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Challenge-2"><span class="nav-text">Challenge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Challenge-3"><span class="nav-text">Challenge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Challenge-4"><span class="nav-text">Challenge</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-The-Web-Server"><span class="nav-text">3. The Web Server</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-13"><span class="nav-text">Exercise 13.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Challenge-5"><span class="nav-text">Challenge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Question-2"><span class="nav-text">Question</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">别云</span>

  
</div>
<div class="powered-by">
  <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
</div>
<!--





-->

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共46.1k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>
  
    <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="true"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
